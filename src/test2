сейчас я скажу тебе свое устройсво файлов а ты поизменяй коды что бы они конектились у меня папка с проектом называется SDL2 в нем лежит все что есть тоесть   Makefile README.md и папки bin, font , img , music , save , src , .git 
в папке bin будет хранится сам исполгяемый файл тоесть при компиляции файл app должен попадать сюда 
 в папке font хранится arial.ttf
в папке img хранятся картинки тесть ZnakMuziki.png и 123.png
в папке music хранится музыка ее не трогай 
в папке save будут хранится сохранения ВСЕ 
в папке src будет хранится весь код тоесть main.cpp и рядом с ним в отдельных папках будут хранится остальные файлы по типу в папке towerDefens будет хранится сам файл с++ и его заголовочный файл и остальные файлы относящиеся к игре 
папку .git я думаю трогать не стоит
такс кстати файлы библиотек передвинь в отдельную папку рядом с main.cpp и называтся папка будет biblioteki
common файлы хранятся в папке common рядом с main.cpp библиотеки хранятся в папке biblioteki и tinyfiledialogs имеет версию 2.9.3

ниже будет код который ты написал в прошлом чате 
main.cpp
#include "common/common.h"
#include "musicPlayer/musicPlayer.h"
#include "towerDefens/towerDefens.h"
#include <iostream>
#include <fstream>

int main(int argc, char* argv[]) {
    SDL_SetMainReady();
    setlocale(LC_ALL, "ru_RU.UTF-8");
    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1");

    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
        std::cerr << "Ошибка инициализации SDL: " << SDL_GetError() << std::endl;
        return 1;
    }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        std::cerr << "SDL_mixer could not initialize! SDL_mixer Error: " << Mix_GetError() << std::endl;
        SDL_Quit();
        return 1;
    }
    int imgFlags = IMG_INIT_PNG;
    if (!(IMG_Init(imgFlags) & imgFlags)) {
        std::cerr << "IMG_Init Error: " << IMG_GetError() << std::endl;
        SDL_Quit();
        return 1;
    }
    if (TTF_Init() == -1) {
        std::cerr << "TTF_Init Error: " << TTF_GetError() << std::endl;
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    TTF_Font* font = TTF_OpenFont("font/arial.ttf", 20);
    TTF_Font* trackFont = TTF_OpenFont("font/arial.ttf", 40);
    TTF_Font* titleFont = TTF_OpenFont("font/arial.ttf", 48);
    if (!font || !trackFont || !titleFont) {
        std::cerr << "TTF_OpenFont Error: " << TTF_GetError() << std::endl;
        TTF_CloseFont(font);
        TTF_CloseFont(trackFont);
        TTF_CloseFont(titleFont);
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("Музыкальный плеер", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 750, SDL_WINDOW_SHOWN);
    if (!window) {
        std::cerr << "Ошибка создания окна: " << SDL_GetError() << std::endl;
        TTF_CloseFont(font);
        TTF_CloseFont(trackFont);
        TTF_CloseFont(titleFont);
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (!renderer) {
        std::cerr << "Ошибка создания рендера: " << SDL_GetError() << std::endl;
        SDL_DestroyWindow(window);
        TTF_CloseFont(font);
        TTF_CloseFont(trackFont);
        TTF_CloseFont(titleFont);
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Surface* logoSurface = IMG_Load("img/ZnakMuziki.png");
    SDL_Texture* logoTexture = nullptr;
    if (logoSurface) {
        logoTexture = SDL_CreateTextureFromSurface(renderer, logoSurface);
        SDL_FreeSurface(logoSurface);
    }

    std::string musicPath = "music/muzika.mp3";
    std::string folderPath;
    std::ifstream musicPathFile("save/music_path.txt");
    if (musicPathFile.is_open()) {
        std::getline(musicPathFile, musicPath);
        std::getline(musicPathFile, folderPath);
        musicPathFile.close();
    }

    MusicPlayer musicPlayer;
    musicPlayer.init(musicPath, folderPath);
    TowerDefens towerDefens;
    towerDefens.init();

    SDL_Rect menuButton1 = {300, 300, 200, 75};
    SDL_Rect menuButton2 = {300, 400, 200, 75};
    SDL_Rect menuButton3 = {300, 500, 200, 75};
    SDL_Rect menuButton4 = {300, 600, 200, 75};
    int scene = -1;
    bool running = true;
    SDL_Event event;

    while (running) {
        int mx, my;
        SDL_GetMouseState(&mx, &my);
        SDL_Rect cursor = {mx, my, 2, 2};

        bool MouseOnMenuButton1 = SDL_HasIntersection(&cursor, &menuButton1);
        bool MouseOnMenuButton2 = SDL_HasIntersection(&cursor, &menuButton2);
        bool MouseOnMenuButton3 = SDL_HasIntersection(&cursor, &menuButton3);
        bool MouseOnMenuButton4 = SDL_HasIntersection(&cursor, &menuButton4);

        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                running = false;
            } else if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_ESCAPE) {
                if (scene == -1) {
                    running = false;
                } else {
                    scene = -1; // Возврат в главное меню
                }
            } else if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT && scene == -1) {
                if (MouseOnMenuButton1) {
                    scene = 1; // Переход к музыкальному плееру
                } else if (MouseOnMenuButton2) {
                    scene = 2; // Переход к игре Tower Defense
                } else if (MouseOnMenuButton3) {
                    // Зарезервировано для будущей функциональности
                } else if (MouseOnMenuButton4) {
                    running = false; // Выход
                }
            } else if (scene == 1) {
                musicPlayer.handleEvents(event, renderer, font, trackFont, mx, my, running);
            } else if (scene == 2) {
                towerDefens.handleEvents(event, mx, my, scene);
            }
        }

        SDL_SetRenderDrawColor(renderer, bgColor.r, bgColor.g, bgColor.b, bgColor.a);
        SDL_RenderClear(renderer);

        if (scene == -1) {
            // Отрисовка главного меню
            if (logoTexture) {
                SDL_Rect logoRect = {300, 100, 200, 200};
                SDL_RenderCopy(renderer, logoTexture, nullptr, &logoRect);
            }

            SDL_SetRenderDrawColor(renderer, MouseOnMenuButton1 ? buttonHoverColor.r : buttonColor.r,
                                   MouseOnMenuButton1 ? buttonHoverColor.g : buttonColor.g,
                                   MouseOnMenuButton1 ? buttonHoverColor.b : buttonColor.b, 255);
            SDL_RenderFillRect(renderer, &menuButton1);
            SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
            SDL_RenderDrawRect(renderer, &menuButton1);
            SDL_Texture* btn1Text = createTextTexture(renderer, font, "Музыкальный плеер", textColor, 180);
            if (btn1Text) {
                int tw, th;
                SDL_QueryTexture(btn1Text, nullptr, nullptr, &tw, &th);
                SDL_Rect tr = {menuButton1.x + (menuButton1.w - tw) / 2, menuButton1.y + (menuButton1.h - th) / 2, tw, th};
                SDL_RenderCopy(renderer, btn1Text, nullptr, &tr);
                SDL_DestroyTexture(btn1Text);
            }

            SDL_SetRenderDrawColor(renderer, MouseOnMenuButton2 ? buttonHoverColor.r : buttonColor.r,
                                   MouseOnMenuButton2 ? buttonHoverColor.g : buttonColor.g,
                                   MouseOnMenuButton2 ? buttonHoverColor.b : buttonColor.b, 255);
            SDL_RenderFillRect(renderer, &menuButton2);
            SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
            SDL_RenderDrawRect(renderer, &menuButton2);
            SDL_Texture* btn2Text = createTextTexture(renderer, font, "Tower Defense", textColor, 180);
            if (btn2Text) {
                int tw, th;
                SDL_QueryTexture(btn2Text, nullptr, nullptr, &tw, &th);
                SDL_Rect tr = {menuButton2.x + (menuButton2.w - tw) / 2, menuButton2.y + (menuButton2.h - th) / 2, tw, th};
                SDL_RenderCopy(renderer, btn2Text, nullptr, &tr);
                SDL_DestroyTexture(btn2Text);
            }

            SDL_SetRenderDrawColor(renderer, MouseOnMenuButton3 ? buttonHoverColor.r : buttonColor.r,
                                   MouseOnMenuButton3 ? buttonHoverColor.g : buttonColor.g,
                                   MouseOnMenuButton3 ? buttonHoverColor.b : buttonColor.b, 255);
            SDL_RenderFillRect(renderer, &menuButton3);
            SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
            SDL_RenderDrawRect(renderer, &menuButton3);
            SDL_Texture* btn3Text = createTextTexture(renderer, font, "Зарезервировано", textColor, 180);
            if (btn3Text) {
                int tw, th;
                SDL_QueryTexture(btn3Text, nullptr, nullptr, &tw, &th);
                SDL_Rect tr = {menuButton3.x + (menuButton3.w - tw) / 2, menuButton3.y + (menuButton3.h - th) / 2, tw, th};
                SDL_RenderCopy(renderer, btn3Text, nullptr, &tr);
                SDL_DestroyTexture(btn3Text);
            }

            SDL_SetRenderDrawColor(renderer, MouseOnMenuButton4 ? buttonHoverColor.r : buttonColor.r,
                                   MouseOnMenuButton4 ? buttonHoverColor.g : buttonColor.g,
                                   MouseOnMenuButton4 ? buttonHoverColor.b : buttonColor.b, 255);
            SDL_RenderFillRect(renderer, &menuButton4);
            SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
            SDL_RenderDrawRect(renderer, &menuButton4);
            SDL_Texture* btn4Text = createTextTexture(renderer, font, "Выход", textColor, 180);
            if (btn4Text) {
                int tw, th;
                SDL_QueryTexture(btn4Text, nullptr, nullptr, &tw, &th);
                SDL_Rect tr = {menuButton4.x + (menuButton4.w - tw) / 2, menuButton4.y + (menuButton4.h - th) / 2, tw, th};
                SDL_RenderCopy(renderer, btn4Text, nullptr, &tr);
                SDL_DestroyTexture(btn4Text);
            }

            SDL_Texture* titleText = createTextTexture(renderer, titleFont, "Главное меню", textColor);
            if (titleText) {
                int tw, th;
                SDL_QueryTexture(titleText, nullptr, nullptr, &tw, &th);
                SDL_Rect tr = {400 - tw / 2, 50, tw, th};
                SDL_RenderCopy(renderer, titleText, nullptr, &tr);
                SDL_DestroyTexture(titleText);
            }
        } else if (scene == 1) {
            musicPlayer.update(renderer, font);
            musicPlayer.render(renderer, font, mx, my);
        } else if (scene == 2) {
            towerDefens.update(renderer, font);
            towerDefens.render(renderer, font, mx, my);
        }

        SDL_RenderPresent(renderer);
    }

    // Очистка ресурсов
    if (logoTexture) SDL_DestroyTexture(logoTexture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_CloseFont(font);
    TTF_CloseFont(trackFont);
    TTF_CloseFont(titleFont);
    TTF_Quit();
    IMG_Quit();
    Mix_CloseAudio();
    SDL_Quit();

    return 0;
}



кста если ты будешь делать .o файлы по типу main.o перенеси их в отдельную папку в src под названием file_o

common.cpp
#include "common.h"
#include <iostream>
#include <sstream>
#include <iomanip>

SDL_Color bgColor = {30, 30, 30, 255};
SDL_Color buttonColor = {70, 70, 70, 255};
SDL_Color buttonHoverColor = {100, 100, 100, 255};
SDL_Color borderColor = {255, 255, 255, 255};
SDL_Color textColor = {255, 255, 255, 255};
SDL_Color shadowColor = {0, 0, 0, 128};
SDL_Color sliderTrackColor = {50, 50, 50, 255};
SDL_Color sliderHandleColor = {150, 150, 150, 255};
SDL_Color sliderActiveColor = {255, 165, 0, 255};
SDL_Color enemyColor = {255, 0, 0, 255};
SDL_Color towerColor = {0, 255, 0, 255};
SDL_Color projectileColor = {255, 255, 0, 255};
SDL_Color pathColor = {139, 69, 19, 255};
SDL_Color validPlacementColor = {0, 255, 0, 128};
SDL_Color invalidPlacementColor = {255, 0, 0, 128};

SDL_Texture* createTextTexture(SDL_Renderer* renderer, TTF_Font* font, const std::string& text, SDL_Color color, int maxWidth) {
    if (text.empty()) return nullptr;
    SDL_Surface* textSurface = nullptr;
    if (maxWidth > 0) {
        textSurface = TTF_RenderUTF8_Blended_Wrapped(font, text.c_str(), color, maxWidth);
    } else {
        textSurface = TTF_RenderUTF8_Blended(font, text.c_str(), color);
    }
    if (!textSurface) {
        std::cerr << "TTF_RenderUTF8_Blended Error: " << TTF_GetError() << std::endl;
        return nullptr;
    }
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, textSurface);
    SDL_FreeSurface(textSurface);
    if (!texture) {
        std::cerr << "SDL_CreateTextureFromSurface Error: " << SDL_GetError() << std::endl;
    }
    return texture;
}

std::string formatTime(double seconds) {
    int minutes = static_cast<int>(seconds) / 60;
    int secs = static_cast<int>(seconds) % 60;
    std::stringstream ss;
    ss << std::setfill('0') << std::setw(2) << minutes << ":" << std::setfill('0') << std::setw(2) << secs;
    return ss.str();
}





common.h
#ifndef COMMON_H
#define COMMON_H

#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>
#include <string>
#include <vector>

extern SDL_Color bgColor;
extern SDL_Color buttonColor;
extern SDL_Color buttonHoverColor;
extern SDL_Color borderColor;
extern SDL_Color textColor;
extern SDL_Color shadowColor;
extern SDL_Color sliderTrackColor;
extern SDL_Color sliderHandleColor;
extern SDL_Color sliderActiveColor;
extern SDL_Color enemyColor;
extern SDL_Color towerColor;
extern SDL_Color projectileColor;
extern SDL_Color pathColor;
extern SDL_Color validPlacementColor;
extern SDL_Color invalidPlacementColor;

SDL_Texture* createTextTexture(SDL_Renderer* renderer, TTF_Font* font, const std::string& text, SDL_Color color, int maxWidth = 0);
std::string formatTime(double seconds);

#endif // COMMON_H


musicPlayer.cpp
#include "musicPlayer.h"

MusicPlayer::MusicPlayer() : musicPath("music/muzika.mp3"), bgm(nullptr), currentTrackIndex(0), musicStarted(false),
    trackText(nullptr), currentTimeText(nullptr), totalTimeText(nullptr), hoverTimeText(nullptr),
    coverTexture(nullptr), musicDuration(0.0), needsScrolling(false), textOffset(0), lastTextUpdate(0),
    coverRect({300, 100, 200, 200}), knopka1({0, 0, 200, 75}), knopka2({0, 75, 200, 75}),
    knopka11({340, 550, 120, 75}), sliderTrack({300, 500, 200, 10}), sliderHandle({300, 495, 10, 20}),
    isDraggingSlider(false), musicScrollTrack({790, 50, 10, 385}), musicScrollHandle({790, 50, 10, 20}),
    isDraggingMusicScroll(false), musicScrollOffset(0), maxVisibleSquares(7) {}

MusicPlayer::~MusicPlayer() {
    if (bgm) Mix_FreeMusic(bgm);
    if (trackText) SDL_DestroyTexture(trackText);
    if (currentTimeText) SDL_DestroyTexture(currentTimeText);
    if (totalTimeText) SDL_DestroyTexture(totalTimeText);
    if (hoverTimeText) SDL_DestroyTexture(hoverTimeText);
    if (coverTexture) SDL_DestroyTexture(coverTexture);
    for (auto& texture : musicFileTextures) {
        if (texture) SDL_DestroyTexture(texture);
    }
}

void MusicPlayer::init(const std::string& initialMusicPath, const std::string& initialFolderPath) {
    musicPath = initialMusicPath;
    folderPath = initialFolderPath;
    if (!folderPath.empty() && fs::exists(folderPath)) {
        for (const auto& entry : fs::directory_iterator(folderPath)) {
            if (entry.path().extension() == ".mp3" || entry.path().extension() == ".wav") {
                musicFiles.push_back(entry.path().string());
                if (entry.path().string() == musicPath) {
                    currentTrackIndex = musicFiles.size() - 1;
                }
            }
        }
    }
    bgm = Mix_LoadMUS(musicPath.c_str());
    if (!bgm) {
        std::cerr << "Failed to load bgm! SDL_mixer Error: " << Mix_GetError() << std::endl;
    }
    musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
    currentTrack = fs::path(musicPath).filename().string();
    needsScrolling = currentTrack.length() > 15;
    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
}

void MusicPlayer::handleEvents(SDL_Event& event, SDL_Renderer* renderer, TTF_Font* font, TTF_Font* trackFont, int mx, int my, bool& running) {
    bool MouseOnKnopka1 = isMouseOnButton(mx, my, knopka1);
    bool MouseOnKnopka2 = isMouseOnButton(mx, my, knopka2);
    bool MouseOnKnopka11 = isMouseOnButton(mx, my, knopka11);
    bool MouseOnSlider = isMouseOnButton(mx, my, sliderHandle);
    bool MouseOnSliderTrack = (mx >= sliderTrack.x && mx <= sliderTrack.x + sliderTrack.w && my >= sliderTrack.y && my <= sliderTrack.y + sliderTrack.h);
    bool MouseOnMusicScroll = isMouseOnButton(mx, my, musicScrollHandle);
    bool MouseOnCover = isMouseOnButton(mx, my, coverRect);
    std::vector<bool> MouseOnMusicSquare(musicSquares.size(), false);
    for (size_t i = 0; i < musicSquares.size(); ++i) {
        MouseOnMusicSquare[i] = isMouseOnButton(mx, my, musicSquares[i]);
    }

    if (event.type == SDL_KEYDOWN) {
        if (event.key.keysym.sym == SDLK_1 && bgm && !musicStarted) {
            if (Mix_PlayMusic(bgm, -1) == -1) {
                std::cerr << "Mix_PlayMusic error: " << Mix_GetError() << std::endl;
            } else {
                musicStarted = true;
            }
        } else if (event.key.keysym.sym == SDLK_SPACE) {
            if (Mix_PausedMusic()) {
                Mix_ResumeMusic();
            } else {
                Mix_PauseMusic();
            }
        } else if (event.key.keysym.sym == SDLK_UP && !musicFiles.empty()) {
            if (currentTrackIndex > 0) {
                currentTrackIndex--;
            } else {
                currentTrackIndex = musicFiles.size() - 1;
            }
            musicPath = musicFiles[currentTrackIndex];
            if (musicStarted) {
                Mix_HaltMusic();
                musicStarted = false;
            }
            if (bgm) {
                Mix_FreeMusic(bgm);
            }
            bgm = Mix_LoadMUS(musicPath.c_str());
            if (!bgm) {
                std::cerr << "Failed to load new bgm! SDL_mixer Error: " << Mix_GetError() << std::endl;
            } else {
                if (Mix_PlayMusic(bgm, -1) == -1) {
                    std::cerr << "Mix_PlayMusic error: " << Mix_GetError() << std::endl;
                } else {
                    musicStarted = true;
                }
            }
            if (trackText) SDL_DestroyTexture(trackText);
            currentTrack = fs::path(musicPath).filename().string();
            trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
            needsScrolling = currentTrack.length() > 15;
            textOffset = 0;
            if (totalTimeText) SDL_DestroyTexture(totalTimeText);
            musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
            totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
            if (coverTexture) SDL_DestroyTexture(coverTexture);
            coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
            if (fs::exists(coverPath)) {
                SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                if (coverSurface) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                    SDL_FreeSurface(coverSurface);
                }
            } else {
                SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                if (defaultCover) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                    SDL_FreeSurface(defaultCover);
                }
            }
            std::ofstream outFile("save/music_path.txt");
            if (outFile.is_open()) {
                outFile << musicPath << "\n" << folderPath;
                outFile.close();
            }
        } else if (event.key.keysym.sym == SDLK_DOWN && !musicFiles.empty()) {
            if (currentTrackIndex < musicFiles.size() - 1) {
                currentTrackIndex++;
            } else {
                currentTrackIndex = 0;
            }
            musicPath = musicFiles[currentTrackIndex];
            if (musicStarted) {
                Mix_HaltMusic();
                musicStarted = false;
            }
            if (bgm) {
                Mix_FreeMusic(bgm);
            }
            bgm = Mix_LoadMUS(musicPath.c_str());
            if (!bgm) {
                std::cerr << "Failed to load new bgm! SDL_mixer Error: " << Mix_GetError() << std::endl;
            } else {
                if (Mix_PlayMusic(bgm, -1) == -1) {
                    std::cerr << "Mix_PlayMusic error: " << Mix_GetError() << std::endl;
                } else {
                    musicStarted = true;
                }
            }
            if (trackText) SDL_DestroyTexture(trackText);
            currentTrack = fs::path(musicPath).filename().string();
            trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
            needsScrolling = currentTrack.length() > 15;
            textOffset = 0;
            if (totalTimeText) SDL_DestroyTexture(totalTimeText);
            musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
            totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
            if (coverTexture) SDL_DestroyTexture(coverTexture);
            coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
            if (fs::exists(coverPath)) {
                SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                if (coverSurface) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                    SDL_FreeSurface(coverSurface);
                }
            } else {
                SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                if (defaultCover) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                    SDL_FreeSurface(defaultCover);
                }
            }
            std::ofstream outFile("save/music_path.txt");
            if (outFile.is_open()) {
                outFile << musicPath << "\n" << folderPath;
                outFile.close();
            }
        } else if (event.key.keysym.sym == SDLK_LEFT && bgm && musicStarted) {
            double currentPosition = Mix_GetMusicPosition(bgm);
            double newPosition = std::max(0.0, currentPosition - 5.0);
            Mix_SetMusicPosition(newPosition);
        } else if (event.key.keysym.sym == SDLK_RIGHT && bgm && musicStarted) {
            double currentPosition = Mix_GetMusicPosition(bgm);
            double musicDuration = Mix_MusicDuration(bgm);
            double newPosition = std::min(musicDuration, currentPosition + 5.0);
            Mix_SetMusicPosition(newPosition);
        }
    } else if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT) {
        if (MouseOnKnopka1) {
            const char* selectedFolder = tinyfd_selectFolderDialog("Выберите папку с музыкой", "");
            if (selectedFolder) {
                folderPath = selectedFolder;
                musicFiles.clear();
                musicSquares.clear();
                for (auto& texture : musicFileTextures) {
                    if (texture) SDL_DestroyTexture(texture);
                }
                musicFileTextures.clear();
                currentTrackIndex = 0;
                for (const auto& entry : fs::directory_iterator(folderPath)) {
                    if (entry.path().extension() == ".mp3" || entry.path().extension() == ".wav") {
                        musicFiles.push_back(entry.path().string());
                        std::string filename = fs::path(entry.path()).filename().string();
                        SDL_Texture* textTexture = createTextTexture(renderer, font, filename, textColor, 130);
                        musicFileTextures.push_back(textTexture);
                    }
                }
                musicScrollOffset = 0;
                musicSquares.clear();
                for (size_t i = 0; i < musicFiles.size() && i < maxVisibleSquares; ++i) {
                    musicSquares.push_back({650, static_cast<int>(50 + i * 55), 140, 50});
                }
                if (!musicFiles.empty()) {
                    musicPath = musicFiles[0];
                    if (musicStarted) {
                        Mix_HaltMusic();
                        musicStarted = false;
                    }
                    if (bgm) {
                        Mix_FreeMusic(bgm);
                    }
                    bgm = Mix_LoadMUS(musicPath.c_str());
                    if (trackText) SDL_DestroyTexture(trackText);
                    currentTrack = fs::path(musicPath).filename().string();
                    trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
                    needsScrolling = currentTrack.length() > 15;
                    textOffset = 0;
                    if (totalTimeText) SDL_DestroyTexture(totalTimeText);
                    musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
                    totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
                    if (coverTexture) SDL_DestroyTexture(coverTexture);
                    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
                    if (fs::exists(coverPath)) {
                        SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                        if (coverSurface) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                            SDL_FreeSurface(coverSurface);
                        }
                    } else {
                        SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                        if (defaultCover) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                            SDL_FreeSurface(defaultCover);
                        }
                    }
                }
                std::ofstream outFile("save/music_path.txt");
                if (outFile.is_open()) {
                    outFile << musicPath << "\n" << folderPath;
                    outFile.close();
                }
            }
        } else if (MouseOnKnopka2) {
            running = false;
        } else if (MouseOnKnopka11) {
            if (Mix_PausedMusic()) {
                Mix_ResumeMusic();
            } else {
                Mix_PauseMusic();
            }
        } else if (MouseOnSlider) {
            isDraggingSlider = true;
        } else if (MouseOnMusicScroll) {
            isDraggingMusicScroll = true;
        } else if (MouseOnSliderTrack && bgm) {
            double musicDuration = Mix_MusicDuration(bgm);
            if (musicDuration > 0) {
                float progress = static_cast<float>(mx - sliderTrack.x) / sliderTrack.w;
                double newPosition = progress * musicDuration;
                Mix_SetMusicPosition(newPosition);
            }
        } else if (MouseOnCover) {
            const char* selectedImage = tinyfd_openFileDialog("Выберите обложку", "", 0, nullptr, nullptr, 0);
            if (selectedImage) {
                SDL_Surface* newCoverSurface = IMG_Load(selectedImage);
                if (newCoverSurface) {
                    if (coverTexture) SDL_DestroyTexture(coverTexture);
                    coverTexture = SDL_CreateTextureFromSurface(renderer, newCoverSurface);
                    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
                    IMG_SavePNG(newCoverSurface, coverPath.c_str());
                    SDL_FreeSurface(newCoverSurface);
                }
            }
        } else {
            for (size_t i = 0; i < musicSquares.size(); ++i) {
                if (MouseOnMusicSquare[i] && i + musicScrollOffset < musicFiles.size()) {
                    currentTrackIndex = i + musicScrollOffset;
                    musicPath = musicFiles[currentTrackIndex];
                    if (musicStarted) {
                        Mix_HaltMusic();
                        musicStarted = false;
                    }
                    if (bgm) {
                        Mix_FreeMusic(bgm);
                    }
                    bgm = Mix_LoadMUS(musicPath.c_str());
                    if (!bgm) {
                        std::cerr << "Failed to load new bgm! SDL_mixer Error: " << Mix_GetError() << std::endl;
                    } else {
                        if (Mix_PlayMusic(bgm, -1) == -1) {
                            std::cerr << "Mix_PlayMusic error: " << Mix_GetError() << std::endl;
                        } else {
                            musicStarted = true;
                        }
                    }
                    if (trackText) SDL_DestroyTexture(trackText);
                    currentTrack = fs::path(musicPath).filename().string();
                    trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
                    needsScrolling = currentTrack.length() > 15;
                    textOffset = 0;
                    if (totalTimeText) SDL_DestroyTexture(totalTimeText);
                    musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
                    totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
                    if (coverTexture) SDL_DestroyTexture(coverTexture);
                    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
                    if (fs::exists(coverPath)) {
                        SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                        if (coverSurface) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                            SDL_FreeSurface(coverSurface);
                        }
                    } else {
                        SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                        if (defaultCover) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                            SDL_FreeSurface(defaultCover);
                        }
                    }
                    std::ofstream outFile("save/music_path.txt");
                    if (outFile.is_open()) {
                        outFile << musicPath << "\n" << folderPath;
                        outFile.close();
                    }
                    break;
                }
            }
        }
    } else if (event.type == SDL_MOUSEBUTTONUP && event.button.button == SDL_BUTTON_LEFT) {
        if (isDraggingSlider) {
            isDraggingSlider = false;
            if (bgm && musicStarted) {
                double musicDuration = Mix_MusicDuration(bgm);
                if (musicDuration > 0) {
                    float progress = static_cast<float>(sliderHandle.x - sliderTrack.x) / (sliderTrack.w - sliderHandle.w);
                    double newPosition = progress * musicDuration;
                    Mix_SetMusicPosition(newPosition);
                }
            }
        } else if (isDraggingMusicScroll) {
            isDraggingMusicScroll = false;
        }
    } else if (event.type == SDL_MOUSEMOTION) {
        if (isDraggingSlider) {
            int newX = mx - sliderHandle.w / 2;
            if (newX < sliderTrack.x) newX = sliderTrack.x;
            if (newX > sliderTrack.x + sliderTrack.w - sliderHandle.w) newX = sliderTrack.x + sliderTrack.w - sliderHandle.w;
            sliderHandle.x = newX;
        } else if (isDraggingMusicScroll && musicFiles.size() > maxVisibleSquares) {
            int newY = my - musicScrollHandle.h / 2;
            if (newY < musicScrollTrack.y) newY = musicScrollTrack.y;
            if (newY > musicScrollTrack.y + musicScrollTrack.h - musicScrollHandle.h) newY = musicScrollTrack.y + musicScrollTrack.h - musicScrollHandle.h;
            musicScrollHandle.y = newY;
            float progress = static_cast<float>(musicScrollHandle.y - musicScrollTrack.y) / (musicScrollTrack.h - musicScrollHandle.h);
            musicScrollOffset = static_cast<int>(progress * (musicFiles.size() - maxVisibleSquares));
            musicSquares.clear();
            for (size_t i = musicScrollOffset; i < musicFiles.size() && i < musicScrollOffset + maxVisibleSquares; ++i) {
                musicSquares.push_back({650, static_cast<int>(50 + (i - musicScrollOffset) * 55), 140, 50});
            }
        }
    }
}

void MusicPlayer::update(SDL_Renderer* renderer, TTF_Font* font) {
    if (bgm && musicStarted && !isDraggingSlider) {
        double currentPosition = Mix_GetMusicPosition(bgm);
        if (musicDuration > 0) {
            float progress = static_cast<float>(currentPosition) / musicDuration;
            sliderHandle.x = sliderTrack.x + static_cast<int>(progress * (sliderTrack.w - sliderHandle.w));
        }
        if (currentTimeText) SDL_DestroyTexture(currentTimeText);
        currentTimeText = createTextTexture(renderer, font, formatTime(currentPosition), textColor);
    }
    if (needsScrolling) {
        Uint32 currentTime = SDL_GetTicks();
        if (currentTime - lastTextUpdate >= 50) {
            textOffset++;
            int textW, textH;
            SDL_QueryTexture(trackText, nullptr, nullptr, &textW, &textH);
            if (textOffset >= textW - 300) {
                textOffset = 0;
            }
            lastTextUpdate = currentTime;
        }
    } else {
        textOffset = 0;
    }
    if (!isDraggingMusicScroll && musicFiles.size() > maxVisibleSquares) {
        float progress = static_cast<float>(musicScrollOffset) / (musicFiles.size() - maxVisibleSquares);
        musicScrollHandle.y = musicScrollTrack.y + static_cast<int>(progress * (musicScrollTrack.h - musicScrollHandle.h));
    }
}

void MusicPlayer::render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my) {
    bool MouseOnKnopka1 = isMouseOnButton(mx, my, knopka1);
    bool MouseOnKnopka2 = isMouseOnButton(mx, my, knopka2);
    bool MouseOnKnopka11 = isMouseOnButton(mx, my, knopka11);
    bool MouseOnSlider = isMouseOnButton(mx, my, sliderHandle);
    bool MouseOnSliderTrack = (mx >= sliderTrack.x && mx <= sliderTrack.x + sliderTrack.w && my >= sliderTrack.y && my <= sliderTrack.y + sliderTrack.h);
    bool MouseOnMusicScroll = isMouseOnButton(mx, my, musicScrollHandle);
    bool MouseOnCover = isMouseOnButton(mx, my, coverRect);
    std::vector<bool> MouseOnMusicSquare(musicSquares.size(), false);
    for (size_t i = 0; i < musicSquares.size(); ++i) {
        MouseOnMusicSquare[i] = isMouseOnButton(mx, my, musicSquares[i]);
    }

    SDL_Rect shadowRect = {coverRect.x + 5, coverRect.y + 5, coverRect.w, coverRect.h};
    SDL_SetRenderDrawColor(renderer, shadowColor.r, shadowColor.g, shadowColor.b, shadowColor.a);
    SDL_RenderFillRect(renderer, &shadowRect);
    SDL_SetRenderDrawColor(renderer, buttonColor.r, buttonColor.g, buttonColor.b, buttonColor.a);
    SDL_RenderFillRect(renderer, &coverRect);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &coverRect);
    if (coverTexture) {
        SDL_RenderCopy(renderer, coverTexture, nullptr, &coverRect);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnKnopka1 ? buttonHoverColor.r : buttonColor.r, MouseOnKnopka1 ? buttonHoverColor.g : buttonColor.g, MouseOnKnopka1 ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_RenderFillRect(renderer, &knopka1);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &knopka1);
    SDL_Texture* btn1Text = createTextTexture(renderer, font, "Выбрать папку", textColor, 180);
    if (btn1Text) {
        int tw, th;
        SDL_QueryTexture(btn1Text, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {knopka1.x + (knopka1.w - tw) / 2, knopka1.y + (knopka1.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(btn1Text, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(btn1Text, shadowColor.a);
        SDL_RenderCopy(renderer, btn1Text, nullptr, &shadowTr);
        SDL_SetTextureColorMod(btn1Text, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(btn1Text, 255);
        SDL_RenderCopy(renderer, btn1Text, nullptr, &tr);
        SDL_DestroyTexture(btn1Text);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnKnopka2 ? buttonHoverColor.r : buttonColor.r, MouseOnKnopka2 ? buttonHoverColor.g : buttonColor.g, MouseOnKnopka2 ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_RenderFillRect(renderer, &knopka2);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &knopka2);
    SDL_Texture* btn2Text = createTextTexture(renderer, font, "Выход", textColor, 180);
    if (btn2Text) {
        int tw, th;
        SDL_QueryTexture(btn2Text, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {knopka2.x + (knopka2.w - tw) / 2, knopka2.y + (knopka2.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(btn2Text, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(btn2Text, shadowColor.a);
        SDL_RenderCopy(renderer, btn2Text, nullptr, &shadowTr);
        SDL_SetTextureColorMod(btn2Text, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(btn2Text, 255);
        SDL_RenderCopy(renderer, btn2Text, nullptr, &tr);
        SDL_DestroyTexture(btn2Text);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnKnopka11 ? buttonHoverColor.r : buttonColor.r, MouseOnKnopka11 ? buttonHoverColor.g : buttonColor.g, MouseOnKnopka11 ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_RenderFillRect(renderer, &knopka11);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &knopka11);
    SDL_Texture* btn11Text = createTextTexture(renderer, font, Mix_PausedMusic() ? "Играть" : "Пауза", textColor, 100);
    if (btn11Text) {
        int tw, th;
        SDL_QueryTexture(btn11Text, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {knopka11.x + (knopka11.w - tw) / 2, knopka11.y + (knopka11.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(btn11Text, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(btn11Text, shadowColor.a);
        SDL_RenderCopy(renderer, btn11Text, nullptr, &shadowTr);
        SDL_SetTextureColorMod(btn11Text, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(btn11Text, 255);
        SDL_RenderCopy(renderer, btn11Text, nullptr, &tr);
        SDL_DestroyTexture(btn11Text);
    }
    if (trackText) {
        int textW, textH;
        SDL_QueryTexture(trackText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {300 - textOffset, 350, std::min(textW, 300), textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textRect.w, textRect.h};
        SDL_Rect clipRect = {300, 350, 300, textH};
        SDL_RenderSetClipRect(renderer, &clipRect);
        SDL_SetTextureColorMod(trackText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(trackText, shadowColor.a);
        SDL_RenderCopy(renderer, trackText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(trackText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(trackText, 255);
        SDL_RenderCopy(renderer, trackText, nullptr, &textRect);
        SDL_RenderSetClipRect(renderer, nullptr);
    }
    SDL_SetRenderDrawColor(renderer, sliderTrackColor.r, sliderTrackColor.g, sliderTrackColor.b, sliderTrackColor.a);
    SDL_RenderFillRect(renderer, &sliderTrack);
    int handlePos = sliderHandle.x - sliderTrack.x;
    SDL_Rect activePart = {sliderTrack.x, sliderTrack.y, handlePos + sliderHandle.w / 2, sliderTrack.h};
    SDL_SetRenderDrawColor(renderer, sliderActiveColor.r, sliderActiveColor.g, sliderActiveColor.b, sliderActiveColor.a);
    SDL_RenderFillRect(renderer, &activePart);
    SDL_SetRenderDrawColor(renderer, sliderHandleColor.r, sliderHandleColor.g, sliderHandleColor.b, sliderHandleColor.a);
    SDL_RenderFillRect(renderer, &sliderHandle);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &sliderHandle);
    if (currentTimeText) {
        int textW, textH;
        SDL_QueryTexture(currentTimeText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {sliderTrack.x - textW - 5, sliderTrack.y - textH / 2, textW, textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
        SDL_SetTextureColorMod(currentTimeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(currentTimeText, shadowColor.a);
        SDL_RenderCopy(renderer, currentTimeText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(currentTimeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(currentTimeText, 255);
        SDL_RenderCopy(renderer, currentTimeText, nullptr, &textRect);
    }
    if (totalTimeText) {
        int textW, textH;
        SDL_QueryTexture(totalTimeText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {sliderTrack.x + sliderTrack.w + 5, sliderTrack.y - textH / 2, textW, textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
        SDL_SetTextureColorMod(totalTimeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(totalTimeText, shadowColor.a);
        SDL_RenderCopy(renderer, totalTimeText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(totalTimeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(totalTimeText, 255);
        SDL_RenderCopy(renderer, totalTimeText, nullptr, &textRect);
    }
    if (MouseOnSliderTrack && bgm) {
        if (hoverTimeText) SDL_DestroyTexture(hoverTimeText);
        double musicDuration = Mix_MusicDuration(bgm);
        if (musicDuration > 0) {
            float progress = static_cast<float>(mx - sliderTrack.x) / sliderTrack.w;
            double hoverPosition = progress * musicDuration;
            hoverTimeText = createTextTexture(renderer, font, formatTime(hoverPosition), textColor);
        }
    } else {
        if (hoverTimeText) SDL_DestroyTexture(hoverTimeText);
        hoverTimeText = nullptr;
    }
    if (hoverTimeText) {
        int textW, textH;
        SDL_QueryTexture(hoverTimeText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {mx - textW / 2, my - textH - 5, textW, textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
        SDL_SetTextureColorMod(hoverTimeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(hoverTimeText, shadowColor.a);
        SDL_RenderCopy(renderer, hoverTimeText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(hoverTimeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(hoverTimeText, 255);
        SDL_RenderCopy(renderer, hoverTimeText, nullptr, &textRect);
    }
    SDL_SetRenderDrawColor(renderer, sliderTrackColor.r, sliderTrackColor.g, sliderTrackColor.b, sliderTrackColor.a);
    SDL_RenderFillRect(renderer, &musicScrollTrack);
    SDL_SetRenderDrawColor(renderer, MouseOnMusicScroll ? sliderActiveColor.r : sliderHandleColor.r, MouseOnMusicScroll ? sliderActiveColor.g : sliderHandleColor.g, MouseOnMusicScroll ? sliderActiveColor.b : sliderHandleColor.b, 255);
    SDL_RenderFillRect(renderer, &musicScrollHandle);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &musicScrollHandle);
    for (size_t i = 0; i < musicSquares.size(); ++i) {
        SDL_SetRenderDrawColor(renderer, MouseOnMusicSquare[i] ? buttonHoverColor.r : buttonColor.r, MouseOnMusicSquare[i] ? buttonHoverColor.g : buttonColor.g, MouseOnMusicSquare[i] ? buttonHoverColor.b : buttonHoverColor.b, 255);
        SDL_RenderFillRect(renderer, &musicSquares[i]);
        SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
        SDL_RenderDrawRect(renderer, &musicSquares[i]);
        if (i + musicScrollOffset < musicFileTextures.size() && musicFileTextures[i + musicScrollOffset]) {
            int textW, textH;
            SDL_QueryTexture(musicFileTextures[i + musicScrollOffset], nullptr, nullptr, &textW, &textH);
            SDL_Rect textRect = {musicSquares[i].x + 5, musicSquares[i].y + (musicSquares[i].h - textH) / 2, textW, textH};
            SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
            SDL_Rect clipRect = {musicSquares[i].x + 5, musicSquares[i].y, 130, musicSquares[i].h};
            SDL_RenderSetClipRect(renderer, &clipRect);
            SDL_SetTextureColorMod(musicFileTextures[i + musicScrollOffset], shadowColor.r, shadowColor.g, shadowColor.b);
            SDL_SetTextureAlphaMod(musicFileTextures[i + musicScrollOffset], shadowColor.a);
            SDL_RenderCopy(renderer, musicFileTextures[i + musicScrollOffset], nullptr, &shadowRect);
            SDL_SetTextureColorMod(musicFileTextures[i + musicScrollOffset], textColor.r, textColor.g, textColor.b);
            SDL_SetTextureAlphaMod(musicFileTextures[i + musicScrollOffset], 255);
            SDL_RenderCopy(renderer, musicFileTextures[i + musicScrollOffset], nullptr, &textRect);
            SDL_RenderSetClipRect(renderer, nullptr);
        }
    }
}

bool MusicPlayer::isMouseOnButton(int mx, int my, const SDL_Rect& button) {
    SDL_Rect cursor = {mx, my, 2, 2};
    return SDL_HasIntersection(&cursor, &button);
}



musicPlayer.h
#ifndef MUSICPLAYER_H
#define MUSICPLAYER_H

#include "../common/common.h"
#include <vector>
#include <string>
#include <filesystem>
#include "../biblioteki/tinyfiledialogs.h"

class MusicPlayer {
private:
    Mix_Music* bgm;
    std::string currentMusicPath;
    std::vector<std::string> musicFiles;
    std::string folderPath;
    int currentTrackIndex;
    bool isPlaying;
    bool isDraggingSlider;
    bool isDraggingMusicScroll;
    size_t musicScrollOffset;
    double musicPosition;
    double musicLength;
    SDL_Rect sliderTrack;
    SDL_Rect sliderHandle;
    SDL_Rect playPauseButton;
    SDL_Rect nextButton;
    SDL_Rect prevButton;
    SDL_Rect openFolderButton;
    SDL_Rect coverRect;
    std::vector<SDL_Rect> musicSquares;
    SDL_Texture* coverTexture;
    SDL_Texture* trackNameTexture;
    SDL_Texture* timeTexture;
    const size_t maxVisibleSquares;

public:
    MusicPlayer();
    ~MusicPlayer();
    void init(const std::string& musicPath, const std::string& folderPath);
    void handleEvents(SDL_Event& event, SDL_Renderer* renderer, TTF_Font* font, TTF_Font* trackFont, int mx, int my, bool& running);
    void update(SDL_Renderer* renderer, TTF_Font* font);
    void render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my);
    bool isMouseOnButton(int mx, int my, const SDL_Rect& button);
};

#endif





towerDefens.cpp
#include "towerDefens.h"

TowerDefens::TowerDefens() : lastEnemySpawn(0), enemySpawnInterval(2000), playerHealth(10), playerMoney(100),
    towerCost(50), healthText(nullptr), moneyText(nullptr), backButton({650, 650, 120, 75}),
    selectedTowerType(-1), previewTower({0, 0, 50, 50}), isPlacingTower(false), ENEMY_TYPES(10),
    TOWER_TYPES(10), enemyTexture(nullptr), towerTexture(nullptr) {
    enemySpeeds[0] = 2.0f; enemySpeeds[1] = 1.5f; enemySpeeds[2] = 0.8f; enemySpeeds[3] = 3.0f;
    enemySpeeds[4] = 1.0f; enemySpeeds[5] = 2.5f; enemySpeeds[6] = 0.5f; enemySpeeds[7] = 1.8f;
    enemySpeeds[8] = 2.2f; enemySpeeds[9] = 1.2f;
    enemyHealths[0] = 2; enemyHealths[1] = 5; enemyHealths[2] = 10; enemyHealths[3] = 1;
    enemyHealths[4] = 7; enemyHealths[5] = 3; enemyHealths[6] = 15; enemyHealths[7] = 4;
    enemyHealths[8] = 6; enemyHealths[9] = 8;
    towerRanges[0] = 100; towerRanges[1] = 120; towerRanges[2] = 80; towerRanges[3] = 150;
    towerRanges[4] = 90; towerRanges[5] = 110; towerRanges[6] = 130; towerRanges[7] = 100;
    towerRanges[8] = 140; towerRanges[9] = 95;
    towerDamages[0] = 1; towerDamages[1] = 2; towerDamages[2] = 1; towerDamages[3] = 3;
    towerDamages[4] = 1; towerDamages[5] = 2; towerDamages[6] = 4; towerDamages[7] = 1;
    towerDamages[8] = 3; towerDamages[9] = 2;
    towerFireRates[0] = 1.0f; towerFireRates[1] = 0.5f; towerFireRates[2] = 2.0f; towerFireRates[3] = 0.8f;
    towerFireRates[4] = 1.5f; towerFireRates[5] = 1.2f; towerFireRates[6] = 0.6f; towerFireRates[7] = 2.5f;
    towerFireRates[8] = 0.9f; towerFireRates[9] = 1.8f;
    towerNames[0] = "Basic"; towerNames[1] = "Cannon"; towerNames[2] = "Laser"; towerNames[3] = "Slow";
    towerNames[4] = "Sniper"; towerNames[5] = "Multi"; towerNames[6] = "Bomb"; towerNames[7] = "Freeze";
    towerNames[8] = "Poison"; towerNames[9] = "Tesla";
}

TowerDefens::~TowerDefens() {
    if (healthText) SDL_DestroyTexture(healthText);
    if (moneyText) SDL_DestroyTexture(moneyText);
    if (enemyTexture) SDL_DestroyTexture(enemyTexture);
    if (towerTexture) SDL_DestroyTexture(towerTexture);
}

void TowerDefens::init() {
    enemyPath = {{50, 50}, {700, 50}, {700, 300}, {50, 300}, {50, 550}, {700, 550}};
    towerCards.resize(TOWER_TYPES);
    for (int i = 0; i < TOWER_TYPES; ++i) {
        towerCards[i] = {10 + i * 75, 650, 70, 90};
    }
}

void TowerDefens::handleEvents(SDL_Event& event, int mx, int my, int& scene) {
    bool MouseOnBackButton = isMouseOnButton(mx, my, backButton);
    std::vector<bool> MouseOnTowerCard(TOWER_TYPES, false);
    for (int i = 0; i < TOWER_TYPES; ++i) {
        MouseOnTowerCard[i] = isMouseOnButton(mx, my, towerCards[i]);
    }

    if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT) {
        if (MouseOnBackButton) {
            scene = -1;
            enemies.clear();
            towers.clear();
            projectiles.clear();
            playerHealth = 10;
            playerMoney = 100;
            selectedTowerType = -1;
            isPlacingTower = false;
        } else if (isPlacingTower && selectedTowerType >= 0) {
            int towerX = mx - 25;
            int towerY = my - 25;
            if (isValidPlacement(towerX, towerY, towers) && playerMoney >= towerCost) {
                Tower tower = {towerX, towerY, towerRanges[selectedTowerType], towerDamages[selectedTowerType], towerFireRates[selectedTowerType], 0.0f, true, selectedTowerType};
                towers.push_back(tower);
                playerMoney -= towerCost;
                selectedTowerType = -1;
                isPlacingTower = false;
            }
        } else {
            for (int i = 0; i < TOWER_TYPES; ++i) {
                if (MouseOnTowerCard[i] && playerMoney >= towerCost) {
                    selectedTowerType = i;
                    isPlacingTower = true;
                    break;
                }
            }
        }
    } else if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_RIGHT && isPlacingTower) {
        selectedTowerType = -1;
        isPlacingTower = false;
    }
}

void TowerDefens::update(SDL_Renderer* renderer, TTF_Font* font) {
    Uint32 currentTime = SDL_GetTicks();
    if (currentTime - lastEnemySpawn >= enemySpawnInterval && playerHealth > 0) {
        int enemyType = rand() % ENEMY_TYPES;
        Enemy enemy = {50.0f, 50.0f, enemySpeeds[enemyType], enemyHealths[enemyType], 0, true, enemyType};
        enemies.push_back(enemy);
        lastEnemySpawn = currentTime;
    }

    for (auto& enemy : enemies) {
        if (!enemy.active) continue;
        if (enemy.pathIndex >= enemyPath.size() - 1) {
            enemy.active = false;
            playerHealth--;
            if (playerHealth <= 0) {
                enemies.clear();
                towers.clear();
                projectiles.clear();
                playerHealth = 10;
                playerMoney = 100;
                selectedTowerType = -1;
                isPlacingTower = false;
            }
            continue;
        }
        SDL_Point target = enemyPath[enemy.pathIndex + 1];
        float dx = target.x - enemy.x;
        float dy = target.y - enemy.y;
        float distance = sqrt(dx * dx + dy * dy);
        if (distance < enemy.speed) {
            enemy.pathIndex++;
        } else {
            enemy.x += (dx / distance) * enemy.speed;
            enemy.y += (dy / distance) * enemy.speed;
        }
    }

    for (auto& tower : towers) {
        if (!tower.active) continue;
        if (currentTime - tower.lastShot >= 1000.0f / tower.fireRate) {
            for (auto& enemy : enemies) {
                if (!enemy.active) continue;
                if (inRange(tower, enemy.x, enemy.y)) {
                    Projectile proj;
                    proj.x = tower.x + 25;
                    proj.y = tower.y + 25;
                    proj.speed = 5.0f;
                    proj.damage = towerDamages[tower.type];
                    proj.target = &enemy;
                    proj.active = true;
                    projectiles.push_back(proj);
                    tower.lastShot = currentTime;
                    break;
                }
            }
        }
    }

    for (auto& proj : projectiles) {
        if (!proj.active || !proj.target->active) {
            proj.active = false;
            continue;
        }
        float dx = proj.target->x - proj.x;
        float dy = proj.target->y - proj.y;
        float distance = sqrt(dx * dx + dy * dy);
        if (distance < proj.speed) {
            proj.target->health -= proj.damage;
            proj.active = false;
            if (proj.target->health <= 0) {
                proj.target->active = false;
                playerMoney += 10;
            }
        } else {
            proj.x += (dx / distance) * proj.speed;
            proj.y += (dy / distance) * proj.speed;
        }
    }

    projectiles.erase(std::remove_if(projectiles.begin(), projectiles.end(),
        [](const Projectile& p) { return !p.active; }), projectiles.end());

    if (healthText) SDL_DestroyTexture(healthText);
    if (moneyText) SDL_DestroyTexture(moneyText);
    healthText = createTextTexture(renderer, font, "Здоровье: " + std::to_string(playerHealth), textColor);
    moneyText = createTextTexture(renderer, font, "Монеты: " + std::to_string(playerMoney), textColor);

    if (!enemyTexture) {
        SDL_Surface* enemySurface = IMG_Load("img/123.png");
        if (enemySurface) {
            enemyTexture = SDL_CreateTextureFromSurface(renderer, enemySurface);
            SDL_FreeSurface(enemySurface);
        }
    }
    if (!towerTexture) {
        SDL_Surface* towerSurface = IMG_Load("img/123.png");
        if (towerSurface) {
            towerTexture = SDL_CreateTextureFromSurface(renderer, towerSurface);
            SDL_FreeSurface(towerSurface);
        }
    }
}

void TowerDefens::render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my) {
    bool MouseOnBackButton = isMouseOnButton(mx, my, backButton);
    std::vector<bool> MouseOnTowerCard(TOWER_TYPES, false);
    for (int i = 0; i < TOWER_TYPES; ++i) {
        MouseOnTowerCard[i] = isMouseOnButton(mx, my, towerCards[i]);
    }

    SDL_SetRenderDrawColor(renderer, pathColor.r, pathColor.g, pathColor.b, pathColor.a);
    for (size_t i = 0; i < enemyPath.size() - 1; ++i) {
        SDL_RenderDrawLine(renderer, enemyPath[i].x, enemyPath[i].y, enemyPath[i + 1].x, enemyPath[i + 1].y);
    }
    for (const auto& enemy : enemies) {
        if (!enemy.active) continue;
        SDL_Rect enemyRect = {static_cast<int>(enemy.x - 10), static_cast<int>(enemy.y - 10), 20, 20};
        if (enemyTexture) {
            SDL_RenderCopy(renderer, enemyTexture, nullptr, &enemyRect);
        } else {
            SDL_SetRenderDrawColor(renderer, enemyColor.r, enemyColor.g, enemyColor.b, enemyColor.a);
            SDL_RenderFillRect(renderer, &enemyRect);
        }
    }
    for (const auto& tower : towers) {
        if (!tower.active) continue;
        SDL_Rect towerRect = {tower.x, tower.y, 50, 50};
        if (towerTexture) {
            SDL_RenderCopy(renderer, towerTexture, nullptr, &towerRect);
        } else {
            SDL_SetRenderDrawColor(renderer, towerColor.r, towerColor.g, towerColor.b, 255);
            SDL_RenderFillRect(renderer, &towerRect);
        }
        SDL_SetRenderDrawColor(renderer, towerColor.r, towerColor.g, towerColor.b, 50);
        for (int i = 0; i < 360; i++) {
            float rad = i * M_PI / 180.0f;
            int x1 = tower.x + 25 + cos(rad) * towerRanges[tower.type];
            int y1 = tower.y + 25 + sin(rad) * towerRanges[tower.type];
            int x2 = tower.x + 25 + cos((i + 1) * M_PI / 180.0f) * towerRanges[tower.type];
            int y2 = tower.y + 25 + sin((i + 1) * M_PI / 180.0f) * towerRanges[tower.type];
            SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
        }
    }
    SDL_SetRenderDrawColor(renderer, projectileColor.r, projectileColor.g, projectileColor.b, projectileColor.a);
    for (const auto& proj : projectiles) {
        if (!proj.active) continue;
        renderCircle(renderer, static_cast<int>(proj.x), static_cast<int>(proj.y), 3);
    }
    if (healthText) {
        int textW, textH;
        SDL_QueryTexture(healthText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {10, 10, textW, textH};
        SDL_RenderCopy(renderer, healthText, nullptr, &textRect);
    }
    if (moneyText) {
        int textW, textH;
        SDL_QueryTexture(moneyText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {10, 40, textW, textH};
        SDL_RenderCopy(renderer, moneyText, nullptr, &textRect);
    }
    for (int i = 0; i < TOWER_TYPES; ++i) {
        SDL_SetRenderDrawColor(renderer, MouseOnTowerCard[i] ? buttonHoverColor.r : buttonColor.r, MouseOnTowerCard[i] ? buttonHoverColor.g : buttonColor.g, MouseOnTowerCard[i] ? buttonHoverColor.b : buttonHoverColor.b, 255);
        SDL_RenderFillRect(renderer, &towerCards[i]);
        SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
        SDL_RenderDrawRect(renderer, &towerCards[i]);
        SDL_Texture* cardText = createTextTexture(renderer, font, towerNames[i] + "\n" + std::to_string(towerCost), textColor, 60);
        if (cardText) {
            int tw, th;
            SDL_QueryTexture(cardText, nullptr, nullptr, &tw, &th);
            SDL_Rect tr = {towerCards[i].x + (towerCards[i].w - tw) / 2, towerCards[i].y + (towerCards[i].h - th) / 2, tw, th};
            SDL_RenderCopy(renderer, cardText, nullptr, &tr);
            SDL_DestroyTexture(cardText);
        }
    }
    SDL_SetRenderDrawColor(renderer, MouseOnBackButton ? buttonHoverColor.r : buttonColor.r, MouseOnBackButton ? buttonHoverColor.g : buttonColor.g, MouseOnBackButton ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_RenderFillRect(renderer, &backButton);
    SDL_Texture* backText = createTextTexture(renderer, font, "Назад", textColor, 100);
    if (backText) {
        int tw, th;
        SDL_QueryTexture(backText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {backButton.x + (backButton.w - tw) / 2, backButton.y + (backButton.h - th) / 2, tw, th};
        SDL_RenderCopy(renderer, backText, nullptr, &tr);
        SDL_DestroyTexture(backText);
    }
    if (isPlacingTower && selectedTowerType >= 0) {
        previewTower.x = mx - 25;
        previewTower.y = my - 25;
        bool valid = isValidPlacement(previewTower.x, previewTower.y, towers) && playerMoney >= towerCost;
        SDL_SetRenderDrawColor(renderer, valid ? validPlacementColor.r : invalidPlacementColor.r, valid ? validPlacementColor.g : invalidPlacementColor.g, valid ? validPlacementColor.b : invalidPlacementColor.b, valid ? validPlacementColor.a : invalidPlacementColor.a);
        SDL_RenderFillRect(renderer, &previewTower);
        SDL_SetRenderDrawColor(renderer, towerColor.r, towerColor.g, towerColor.b, 50);
        for (int i = 0; i < 360; i++) {
            float rad = i * M_PI / 180.0f;
            int x1 = previewTower.x + 25 + cos(rad) * towerRanges[selectedTowerType];
            int y1 = previewTower.y + 25 + sin(rad) * towerRanges[selectedTowerType];
            int x2 = previewTower.x + 25 + cos((i + 1) * M_PI / 180.0f) * towerRanges[selectedTowerType];
            int y2 = previewTower.y + 25 + sin((i + 1) * M_PI / 180.0f) * towerRanges[selectedTowerType];
            SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
        }
    }
}

bool TowerDefens::isMouseOnButton(int mx, int my, const SDL_Rect& button) {
    SDL_Rect cursor = {mx, my, 2, 2};
    return SDL_HasIntersection(&cursor, &button);
}

bool TowerDefens::inRange(Tower& tower, float px, float py) {
    float dx = tower.x + 25 - px;
    float dy = tower.y + 25 - py;
    return sqrt(dx * dx + dy * dy) <= tower.range;
}

bool TowerDefens::isValidPlacement(int x, int y, const std::vector<Tower>& towers, int towerSize) {
    SDL_Rect newTower = {x, y, towerSize, towerSize};
    for (const auto& tower : towers) {
        if (tower.active) {
            SDL_Rect existingTower = {tower.x, tower.y, towerSize, towerSize};
            if (SDL_HasIntersection(&newTower, &existingTower)) {
                return false;
            }
        }
    }
    for (size_t i = 0; i < enemyPath.size() - 1; ++i) {
        SDL_Point p1 = enemyPath[i];
        SDL_Point p2 = enemyPath[i + 1];
        int pathWidth = 20;
        SDL_Rect pathRect;
        if (p1.x == p2.x) {
            pathRect = {p1.x - pathWidth / 2, std::min(p1.y, p2.y), pathWidth, abs(p2.y - p1.y)};
        } else {
            pathRect = {std::min(p1.x, p2.x), p1.y - pathWidth / 2, abs(p2.x - p1.x), pathWidth};
        }
        if (SDL_HasIntersection(&newTower, &pathRect)) {
            return false;
        }
    }
    if (x < 0 || x + towerSize > 800 || y < 0 || y + towerSize > 650) {
        return false;
    }
    for (const auto& card : towerCards) {
        if (SDL_HasIntersection(&newTower, &card)) {
            return false;
        }
    }
    if (SDL_HasIntersection(&newTower, backButton)) {
        return false;
    }
    return true;
}

void TowerDefens::renderCircle(SDL_Renderer* renderer, int centerX, int centerY, int radius) {
    for (int i = 0; i < 360; i++) {
        float rad = i * M_PI / 180.0f;
        int x1 = centerX + cos(rad) * radius;
        int y1 = centerY + sin(rad) * radius;
        int x2 = centerX + cos((i + 1) * M_PI / 180.0f) * radius;
        int y2 = centerY + sin((i + 1) * M_PI / 180.0f) * radius;
        SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
    }
}


towerDefens.h
#ifndef TOWER_DEFENS_H
#define TOWER_DEFENS_H

#include "../common/common.h"
#include <cmath>

struct Enemy {
    float x, y;
    float speed;
    int health;
    int pathIndex;
    bool active;
    int type;
};

struct Tower {
    int x, y;
    int range;
    int damage;
    float fireRate;
    float lastShot;
    bool active;
    int type;
};

struct Projectile {
    float x, y;
    float speed;
    int damage;
    Enemy* target;
    bool active;
};

class TowerDefens {
private:
    std::vector<SDL_Point> enemyPath;
    std::vector<Enemy> enemies;
    std::vector<Tower> towers;
    std::vector<Projectile> projectiles;
    Uint32 lastEnemySpawn;
    const Uint32 enemySpawnInterval;
    int playerHealth;
    int playerMoney;
    const int towerCost;
    SDL_Texture* healthText;
    SDL_Texture* moneyText;
    SDL_Rect backButton;
    std::vector<SDL_Rect> towerCards;
    int selectedTowerType;
    SDL_Rect previewTower;
    bool isPlacingTower;
    const int ENEMY_TYPES;
    float enemySpeeds[10];
    int enemyHealths[10];
    const int TOWER_TYPES;
    int towerRanges[10];
    int towerDamages[10];
    float towerFireRates[10];
    std::string towerNames[10];
    SDL_Texture* enemyTexture;
    SDL_Texture* towerTexture;

public:
    TowerDefens();
    ~TowerDefens();
    void init();
    void handleEvents(SDL_Event& event, int mx, int my, int& scene);
    void update(SDL_Renderer* renderer, TTF_Font* font);
    void render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my);
    bool isMouseOnButton(int mx, int my, const SDL_Rect& button);
    bool inRange(Tower& tower, float px, float py);
    bool isValidPlacement(int x, int y, const std::vector<Tower>& towers, int towerSize = 50);
    void renderCircle(SDL_Renderer* renderer, int centerX, int centerY, int radius);
};

#endif // TOWER_DEFENS_H

