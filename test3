Makefile

CC := g++
CFLAGS := -Isrc/biblioteki/SDL2 -Isrc/biblioteki -std=c++17 -Wall
TINY_CFLAGS := $(CFLAGS) -Wno-format-overflow
LDFLAGS := -Lsrc/biblioteki/SDL2 -lSDL2 -lSDL2_image -lSDL2_ttf -lSDL2_mixer
OBJDIR := src/file_o
BINDIR := bin
SRCS := src/main.cpp src/common/common.cpp src/mainMenu/mainMenu.cpp src/musicPlayer/musicPlayer.cpp src/settings/settings.cpp src/towerDefens/towerDefens.cpp
TINY_SRC := src/biblioteki/tinyfiledialogs.c
OBJS := $(SRCS:%.cpp=$(OBJDIR)/%.o) $(OBJDIR)/src/biblioteki/tinyfiledialogs.o
TARGET := $(BINDIR)/app

all: $(TARGET)

$(TARGET): $(OBJS)
	@mkdir -p $(BINDIR)
	$(CC) $(OBJS) -o $(TARGET) $(LDFLAGS)

$(OBJDIR)/%.o: %.cpp
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJDIR)/src/biblioteki/tinyfiledialogs.o: $(TINY_SRC)
	@mkdir -p $(dir $@)
	$(CC) $(TINY_CFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJDIR) $(BINDIR)

.PHONY: all clean


main.cpp
#include "common/common.h"
#include "mainMenu/mainMenu.h"
#include "musicPlayer/musicPlayer.h"
#include "settings/settings.h"
#include "towerDefens/towerDefens.h"
#include <filesystem>
#include <fstream>
#include <iostream>

using namespace std;

int main(int argc, char* argv[]) {
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) {
        cerr << "Ошибка инициализации SDL: " << SDL_GetError() << endl;
        return 1;
    }
    if (IMG_Init(IMG_INIT_PNG) != IMG_INIT_PNG) {
        cerr << "Ошибка инициализации SDL_image: " << IMG_GetError() << endl;
        SDL_Quit();
        return 1;
    }
    if (TTF_Init() < 0) {
        cerr << "Ошибка инициализации SDL_ttf: " << TTF_GetError() << endl;
        IMG_Quit();
        SDL_Quit();
        return 1;
    }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        cerr << "Ошибка инициализации SDL_mixer: " << Mix_GetError() << endl;
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    cerr << "Текущая рабочая директория: " << filesystem::current_path() << endl;

    SDL_Window* window = SDL_CreateWindow("SDL2new", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 800, SDL_WINDOW_SHOWN);
    if (!window) {
        cerr << "Ошибка создания окна: " << SDL_GetError() << endl;
        Mix_CloseAudio();
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (!renderer) {
        cerr << "Ошибка создания рендера: " << SDL_GetError() << endl;
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    TTF_Font* font = TTF_OpenFont("font/arial.ttf", 24);
    if (!font) {
        cerr << "Ошибка загрузки шрифта: " << TTF_GetError() << endl;
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    TTF_Font* titleFont = TTF_OpenFont("font/arial.ttf", 48);
    if (!titleFont) {
        cerr << "Ошибка загрузки шрифта заголовка: " << TTF_GetError() << endl;
        TTF_CloseFont(font);
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        Mix_CloseAudio();
        TTF_Quit();
        IMG_Quit();
        SDL_Quit();
        return 1;
    }

    string musicPath = "music/muzika.mp3";
    string folderPath;
    ifstream inFile("save/music_path.txt");
    if (inFile.is_open()) {
        getline(inFile, musicPath);
        getline(inFile, folderPath);
        inFile.close();
    }

    MainMenu mainMenu;
    mainMenu.init(renderer, titleFont);

    MusicPlayer musicPlayer;
    musicPlayer.init(musicPath, folderPath);

    Settings settings;
    settings.init(renderer, font);

    TowerDefens towerDefens;
    towerDefens.init();

    int scene = -1; // Начать с главного меню
    bool running = true;
    SDL_Event event;
    int mx = 0, my = 0;

    while (running) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                running = false;
            } else if (event.type == SDL_MOUSEMOTION) {
                mx = event.motion.x;
                my = event.motion.y;
            } else if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_ESCAPE) {
                if (scene == -1) {
                    running = false;
                } else {
                    scene = -1; // Вернуться в главное меню
                }
            }
            if (scene == -1) {
                mainMenu.handleEvents(event, scene, running, mx, my);
            } else if (scene == 0) {
                musicPlayer.handleEvents(event, renderer, font, titleFont, mx, my, running, scene);
            } else if (scene == 1) {
                towerDefens.handleEvents(event, mx, my, scene);
            } else if (scene == 2) {
                settings.handleEvents(event, scene, mx, my);
            }
        }

        SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255); // Тёмный фон
        SDL_RenderClear(renderer);

        if (scene == -1) {
            mainMenu.render(renderer, titleFont, mx, my);
        } else if (scene == 0) {
            musicPlayer.update(renderer, font);
            musicPlayer.render(renderer, font, mx, my);
        } else if (scene == 1) {
            towerDefens.update(renderer, font);
            towerDefens.render(renderer, font, mx, my);
        } else if (scene == 2) {
            settings.render(renderer, font, mx, my);
        }

        SDL_RenderPresent(renderer);
    }

    TTF_CloseFont(font);
    TTF_CloseFont(titleFont);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    Mix_CloseAudio();
    TTF_Quit();
    IMG_Quit();
    SDL_Quit();
    return 0;
}


towerDefens.h
#ifndef TOWERDEFENS_H
#define TOWERDEFENS_H
#include "../common/common.h"
#include <vector>
#include <string>

class TowerDefens {
public:
    TowerDefens();
    ~TowerDefens();
    void init();
    void handleEvents(SDL_Event& event, int mx, int my, int& scene);
    void update(SDL_Renderer* renderer, TTF_Font* font);
    void render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my);

private:
    struct Enemy {
        float x, y;
        float speed;
        int health;
        size_t pathIndex;
        bool active;
        int type;
    };
    struct Tower {
        int x, y;
        int range;
        int damage;
        float fireRate;
        Uint32 lastShot;
        bool active;
        int type;
    };
    struct Projectile {
        float x, y;
        float speed;
        int damage;
        Enemy* target;
        bool active;
    };
    Uint32 lastEnemySpawn;
    Uint32 enemySpawnInterval;
    int playerHealth;
    int playerMoney;
    int towerCost;
    SDL_Rect backButton;
    SDL_Texture* healthText;
    SDL_Texture* moneyText;
    std::vector<Enemy> enemies;
    std::vector<Tower> towers;
    std::vector<Projectile> projectiles;
    std::vector<SDL_Point> enemyPath;
    int selectedTowerType;
    SDL_Rect previewTower;
    bool isPlacingTower;
    SDL_Texture* enemyTexture;
    SDL_Texture* towerTexture;
    const int ENEMY_TYPES;
    const int TOWER_TYPES;
    float enemySpeeds[10];
    int enemyHealths[10];
    int towerRanges[10];
    int towerDamages[10];
    float towerFireRates[10];
    std::string towerNames[10];
    std::vector<SDL_Rect> towerCards;
    SDL_Color textColor;
    SDL_Color pathColor;
    SDL_Color enemyColor;
    SDL_Color towerColor;
    SDL_Color projectileColor;
    SDL_Color buttonColor;
    SDL_Color buttonHoverColor;
    SDL_Color borderColor;
    SDL_Color validPlacementColor;
    SDL_Color invalidPlacementColor;
    bool isMouseOnButton(int mx, int my, const SDL_Rect& button);
    bool inRange(Tower& tower, float px, float py);
    bool isValidPlacement(int x, int y, const std::vector<Tower>& towers, int towerSize = 50);
    void renderCircle(SDL_Renderer* renderer, int centerX, int centerY, int radius);
};

#endif


towerDefens.cpp
#include "towerDefens.h"
#include <algorithm>
#include <cmath>
#include <iostream>

TowerDefens::TowerDefens() : lastEnemySpawn(0), enemySpawnInterval(2000), playerHealth(10), playerMoney(100),
    towerCost(50), backButton({650, 650, 120, 60}), healthText(nullptr), moneyText(nullptr),
    enemies(), towers(), projectiles(), enemyPath(), selectedTowerType(-1), previewTower({0, 0, 50, 50}),
    isPlacingTower(false), enemyTexture(nullptr), towerTexture(nullptr), ENEMY_TYPES(10), TOWER_TYPES(10),
    textColor({200, 200, 200, 255}), pathColor({80, 80, 80, 255}), enemyColor({200, 100, 100, 255}),
    towerColor({100, 100, 200, 255}), projectileColor({255, 200, 100, 255}),
    buttonColor({40, 40, 60, 255}), buttonHoverColor({60, 60, 90, 255}),
    borderColor({100, 100, 100, 255}), validPlacementColor({100, 200, 100, 150}),
    invalidPlacementColor({200, 100, 100, 150}) {
    enemySpeeds[0] = 2.0f; enemySpeeds[1] = 1.5f; enemySpeeds[2] = 0.8f; enemySpeeds[3] = 3.0f;
    enemySpeeds[4] = 1.0f; enemySpeeds[5] = 2.5f; enemySpeeds[6] = 0.5f; enemySpeeds[7] = 1.8f;
    enemySpeeds[8] = 2.2f; enemySpeeds[9] = 1.2f;
    enemyHealths[0] = 2; enemyHealths[1] = 5; enemyHealths[2] = 10; enemyHealths[3] = 1;
    enemyHealths[4] = 7; enemyHealths[5] = 3; enemyHealths[6] = 15; enemyHealths[7] = 4;
    enemyHealths[8] = 6; enemyHealths[9] = 8;
    towerRanges[0] = 100; towerRanges[1] = 120; towerRanges[2] = 80; towerRanges[3] = 150;
    towerRanges[4] = 90; towerRanges[5] = 110; towerRanges[6] = 130; towerRanges[7] = 100;
    towerRanges[8] = 140; towerRanges[9] = 95;
    towerDamages[0] = 1; towerDamages[1] = 2; towerDamages[2] = 1; towerDamages[3] = 3;
    towerDamages[4] = 1; towerDamages[5] = 2; towerDamages[6] = 4; towerDamages[7] = 1;
    towerDamages[8] = 3; towerDamages[9] = 2;
    towerFireRates[0] = 1.0f; towerFireRates[1] = 0.5f; towerFireRates[2] = 2.0f; towerFireRates[3] = 0.8f;
    towerFireRates[4] = 1.5f; towerFireRates[5] = 1.2f; towerFireRates[6] = 0.6f; towerFireRates[7] = 2.5f;
    towerFireRates[8] = 0.9f; towerFireRates[9] = 1.8f;
    towerNames[0] = "Базовая"; towerNames[1] = "Пушка"; towerNames[2] = "Лазер"; towerNames[3] = "Снайпер";
    towerNames[4] = "Медленная"; towerNames[5] = "Ракета"; towerNames[6] = "Тяжёлая"; towerNames[7] = "Миниган";
    towerNames[8] = "Тесла"; towerNames[9] = "Плазма";
}

TowerDefens::~TowerDefens() {
    if (healthText) SDL_DestroyTexture(healthText);
    if (moneyText) SDL_DestroyTexture(moneyText);
    if (enemyTexture) SDL_DestroyTexture(enemyTexture);
    if (towerTexture) SDL_DestroyTexture(towerTexture);
}

void TowerDefens::init() {
    enemyPath = {{0, 100}, {200, 100}, {200, 300}, {400, 300}, {400, 500}, {600, 500}, {600, 700}, {800, 700}};
    for (int i = 0; i < TOWER_TYPES; ++i) {
        towerCards.push_back({10 + i * 60, 10, 50, 50});
    }
    SDL_Surface* enemySurface = IMG_Load("img/123.png");
    if (enemySurface) {
        enemyTexture = SDL_CreateTextureFromSurface(nullptr, enemySurface);
        SDL_FreeSurface(enemySurface);
        std::cerr << "Текстура врага (img/123.png) загружена успешно" << std::endl;
    } else {
        std::cerr << "Ошибка загрузки текстуры врага: " << IMG_GetError() << std::endl;
    }
    SDL_Surface* towerSurface = IMG_Load("img/123.png");
    if (towerSurface) {
        towerTexture = SDL_CreateTextureFromSurface(nullptr, towerSurface);
        SDL_FreeSurface(towerSurface);
        std::cerr << "Текстура башни (img/123.png) загружена успешно" << std::endl;
    } else {
        std::cerr << "Ошибка загрузки текстуры башни: " << IMG_GetError() << std::endl;
    }
}

void TowerDefens::handleEvents(SDL_Event& event, int mx, int my, int& scene) {
    bool mouseOnBack = isMouseOnButton(mx, my, backButton);
    std::vector<bool> mouseOnCard(TOWER_TYPES, false);
    for (int i = 0; i < TOWER_TYPES; ++i) {
        mouseOnCard[i] = isMouseOnButton(mx, my, towerCards[i]);
    }

    if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT) {
        if (mouseOnBack) {
            scene = -1; // Вернуться в главное меню
        }
        for (int i = 0; i < TOWER_TYPES; ++i) {
            if (mouseOnCard[i] && playerMoney >= towerCost) {
                selectedTowerType = i;
                isPlacingTower = true;
                break;
            }
        }
        if (isPlacingTower && isValidPlacement(mx - 25, my - 25, towers)) {
            towers.push_back({mx - 25, my - 25, towerRanges[selectedTowerType], towerDamages[selectedTowerType],
                towerFireRates[selectedTowerType], 0, true, selectedTowerType});
            playerMoney -= towerCost;
            isPlacingTower = false;
            selectedTowerType = -1;
        }
    } else if (event.type == SDL_MOUSEMOTION) {
        if (isPlacingTower) {
            previewTower.x = mx - 25;
            previewTower.y = my - 25;
        }
    }
}

void TowerDefens::update(SDL_Renderer* renderer, TTF_Font* font) {
    Uint32 currentTime = SDL_GetTicks();
    if (currentTime - lastEnemySpawn > enemySpawnInterval) {
        int type = rand() % ENEMY_TYPES;
        enemies.push_back({static_cast<float>(enemyPath[0].x), static_cast<float>(enemyPath[0].y),
            enemySpeeds[type], enemyHealths[type], 0, true, type});
        lastEnemySpawn = currentTime;
    }
    for (auto& enemy : enemies) {
        if (!enemy.active) continue;
        if (enemy.pathIndex < enemyPath.size() - 1) {
            float dx = enemyPath[enemy.pathIndex + 1].x - enemy.x;
            float dy = enemyPath[enemy.pathIndex + 1].y - enemy.y;
            float distance = std::sqrt(dx * dx + dy * dy);
            if (distance < enemy.speed) {
                enemy.pathIndex++;
                if (enemy.pathIndex >= enemyPath.size()) {
                    enemy.active = false;
                    playerHealth--;
                    continue;
                }
                enemy.x = enemyPath[enemy.pathIndex].x;
                enemy.y = enemyPath[enemy.pathIndex].y;
            } else {
                float vx = (dx / distance) * enemy.speed;
                float vy = (dy / distance) * enemy.speed;
                enemy.x += vx;
                enemy.y += vy;
            }
        }
    }
    for (auto& tower : towers) {
        if (!tower.active) continue;
        if (currentTime - tower.lastShot > (1000.0f / tower.fireRate)) {
            for (auto& enemy : enemies) {
                if (enemy.active && inRange(tower, enemy.x, enemy.y)) {
                    projectiles.push_back({static_cast<float>(tower.x + 25), static_cast<float>(tower.y + 25),
                        5.0f, tower.damage, &enemy, true});
                    tower.lastShot = currentTime;
                    break;
                }
            }
        }
    }
    for (auto& projectile : projectiles) {
        if (!projectile.active || !projectile.target->active) {
            projectile.active = false;
            continue;
        }
        float dx = projectile.target->x - projectile.x;
        float dy = projectile.target->y - projectile.y;
        float distance = std::sqrt(dx * dx + dy * dy);
        if (distance < projectile.speed) {
            projectile.target->health -= projectile.damage;
            if (projectile.target->health <= 0) {
                projectile.target->active = false;
                playerMoney += 10;
            }
            projectile.active = false;
        } else {
            float vx = (dx / distance) * projectile.speed;
            float vy = (dy / distance) * projectile.speed;
            projectile.x += vx;
            projectile.y += vy;
        }
    }
    enemies.erase(std::remove_if(enemies.begin(), enemies.end(), [](const Enemy& e) { return !e.active; }), enemies.end());
    projectiles.erase(std::remove_if(projectiles.begin(), projectiles.end(), [](const Projectile& p) { return !p.active; }), projectiles.end());
    if (healthText) SDL_DestroyTexture(healthText);
    healthText = createTextTexture(renderer, font, "Здоровье: " + std::to_string(playerHealth), textColor);
    if (moneyText) SDL_DestroyTexture(moneyText);
    moneyText = createTextTexture(renderer, font, "Деньги: " + std::to_string(playerMoney), textColor);
}

void TowerDefens::render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my) {
    bool mouseOnBack = isMouseOnButton(mx, my, backButton);
    std::vector<bool> mouseOnCard(TOWER_TYPES, false);
    for (int i = 0; i < TOWER_TYPES; ++i) {
        mouseOnCard[i] = isMouseOnButton(mx, my, towerCards[i]);
    }

    SDL_SetRenderDrawColor(renderer, pathColor.r, pathColor.g, pathColor.b, pathColor.a);
    for (size_t i = 0; i < enemyPath.size() - 1; ++i) {
        SDL_RenderDrawLine(renderer, enemyPath[i].x, enemyPath[i].y, enemyPath[i + 1].x, enemyPath[i + 1].y);
    }
    for (const auto& enemy : enemies) {
        if (!enemy.active) continue;
        if (enemyTexture) {
            SDL_Rect enemyRect = {static_cast<int>(enemy.x - 15), static_cast<int>(enemy.y - 15), 30, 30};
            SDL_RenderCopy(renderer, enemyTexture, nullptr, &enemyRect);
        } else {
            SDL_SetRenderDrawColor(renderer, enemyColor.r, enemyColor.g, enemyColor.b, enemyColor.a);
            renderCircle(renderer, static_cast<int>(enemy.x), static_cast<int>(enemy.y), 15);
        }
    }
    for (const auto& tower : towers) {
        if (!tower.active) continue;
        if (towerTexture) {
            SDL_Rect towerRect = {tower.x, tower.y, 50, 50};
            SDL_RenderCopy(renderer, towerTexture, nullptr, &towerRect);
        } else {
            SDL_SetRenderDrawColor(renderer, towerColor.r, towerColor.g, towerColor.b, towerColor.a);
            SDL_Rect towerRect = {tower.x, tower.y, 50, 50};
            SDL_RenderFillRect(renderer, &towerRect);
        }
        SDL_SetRenderDrawColor(renderer, towerColor.r, towerColor.g, towerColor.b, 100);
        renderCircle(renderer, tower.x + 25, tower.y + 25, tower.range);
    }
    for (const auto& projectile : projectiles) {
        if (!projectile.active) continue;
        SDL_SetRenderDrawColor(renderer, projectileColor.r, projectileColor.g, projectileColor.b, projectileColor.a);
        renderCircle(renderer, static_cast<int>(projectile.x), static_cast<int>(projectile.y), 5);
    }
    for (int i = 0; i < TOWER_TYPES; ++i) {
        SDL_SetRenderDrawColor(renderer, mouseOnCard[i] ? buttonHoverColor.r : buttonColor.r,
            mouseOnCard[i] ? buttonHoverColor.g : buttonColor.g,
            mouseOnCard[i] ? buttonHoverColor.b : buttonHoverColor.b, 255);
        SDL_Rect scaledCard = {towerCards[i].x - (mouseOnCard[i] ? 5 : 0), towerCards[i].y - (mouseOnCard[i] ? 5 : 0),
            towerCards[i].w + (mouseOnCard[i] ? 10 : 0), towerCards[i].h + (mouseOnCard[i] ? 10 : 0)};
        SDL_RenderFillRect(renderer, &scaledCard);
        SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
        SDL_RenderDrawRect(renderer, &scaledCard);
        SDL_Texture* cardText = createTextTexture(renderer, font, towerNames[i], textColor, 40);
        if (cardText) {
            int tw, th;
            SDL_QueryTexture(cardText, nullptr, nullptr, &tw, &th);
            SDL_Rect textRect = {scaledCard.x + (scaledCard.w - tw) / 2, scaledCard.y + (scaledCard.h - th) / 2, tw, th};
            SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, tw, th};
            SDL_SetTextureColorMod(cardText, 50, 50, 50);
            SDL_SetTextureAlphaMod(cardText, 100);
            SDL_RenderCopy(renderer, cardText, nullptr, &shadowRect);
            SDL_SetTextureColorMod(cardText, textColor.r, textColor.g, textColor.b);
            SDL_SetTextureAlphaMod(cardText, 255);
            SDL_RenderCopy(renderer, cardText, nullptr, &textRect);
            SDL_DestroyTexture(cardText);
        }
    }
    if (isPlacingTower) {
        bool valid = isValidPlacement(previewTower.x, previewTower.y, towers);
        SDL_SetRenderDrawColor(renderer, valid ? validPlacementColor.r : invalidPlacementColor.r,
            valid ? validPlacementColor.g : invalidPlacementColor.g,
            valid ? validPlacementColor.b : invalidPlacementColor.b,
            valid ? validPlacementColor.a : invalidPlacementColor.a);
        SDL_RenderFillRect(renderer, &previewTower);
        SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
        SDL_RenderDrawRect(renderer, &previewTower);
        SDL_SetRenderDrawColor(renderer, towerColor.r, towerColor.g, towerColor.b, 100);
        renderCircle(renderer, previewTower.x + 25, previewTower.y + 25, towerRanges[selectedTowerType]);
    }
    if (healthText) {
        int tw, th;
        SDL_QueryTexture(healthText, nullptr, nullptr, &tw, &th);
        SDL_Rect textRect = {10, 70, tw, th};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, tw, th};
        SDL_SetTextureColorMod(healthText, 50, 50, 50);
        SDL_SetTextureAlphaMod(healthText, 100);
        SDL_RenderCopy(renderer, healthText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(healthText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(healthText, 255);
        SDL_RenderCopy(renderer, healthText, nullptr, &textRect);
    }
    if (moneyText) {
        int tw, th;
        SDL_QueryTexture(moneyText, nullptr, nullptr, &tw, &th);
        SDL_Rect textRect = {10, 100, tw, th};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, tw, th};
        SDL_SetTextureColorMod(moneyText, 50, 50, 50);
        SDL_SetTextureAlphaMod(moneyText, 100);
        SDL_RenderCopy(renderer, moneyText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(moneyText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(moneyText, 255);
        SDL_RenderCopy(renderer, moneyText, nullptr, &textRect);
    }
    SDL_SetRenderDrawColor(renderer, mouseOnBack ? buttonHoverColor.r : buttonColor.r,
        mouseOnBack ? buttonHoverColor.g : buttonColor.g,
        mouseOnBack ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_Rect scaledBackButton = {backButton.x - (mouseOnBack ? 5 : 0), backButton.y - (mouseOnBack ? 5 : 0),
        backButton.w + (mouseOnBack ? 10 : 0), backButton.h + (mouseOnBack ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledBackButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledBackButton);
    SDL_Texture* backText = createTextTexture(renderer, font, "Назад", textColor, 100);
    if (backText) {
        int tw, th;
        SDL_QueryTexture(backText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledBackButton.x + (scaledBackButton.w - tw) / 2, scaledBackButton.y + (scaledBackButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(backText, 50, 50, 50);
        SDL_SetTextureAlphaMod(backText, 100);
        SDL_RenderCopy(renderer, backText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(backText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(backText, 255);
        SDL_RenderCopy(renderer, backText, nullptr, &tr);
        SDL_DestroyTexture(backText);
    }
}

bool TowerDefens::isMouseOnButton(int mx, int my, const SDL_Rect& button) {
    SDL_Rect cursor = {mx, my, 2, 2};
    return SDL_HasIntersection(&cursor, &button);
}

bool TowerDefens::inRange(Tower& tower, float px, float py) {
    float dx = (tower.x + 25) - px;
    float dy = (tower.y + 25) - py;
    return std::sqrt(dx * dx + dy * dy) <= tower.range;
}

bool TowerDefens::isValidPlacement(int x, int y, const std::vector<Tower>& towers, int towerSize) {
    SDL_Rect newTower = {x, y, towerSize, towerSize};
    for (const auto& tower : towers) {
        if (!tower.active) continue;
        SDL_Rect existingTower = {tower.x, tower.y, towerSize, towerSize};
        if (SDL_HasIntersection(&newTower, &existingTower)) {
            return false;
        }
    }
    for (size_t i = 0; i < enemyPath.size() - 1; ++i) {
        SDL_Rect pathSegment = {std::min(enemyPath[i].x, enemyPath[i + 1].x),
            std::min(enemyPath[i].y, enemyPath[i + 1].y),
            std::abs(enemyPath[i + 1].x - enemyPath[i].x) + 30,
            std::abs(enemyPath[i + 1].y - enemyPath[i].y) + 30};
        if (SDL_HasIntersection(&newTower, &pathSegment)) {
            return false;
        }
    }
    return x >= 0 && y >= 0 && x + towerSize <= 800 && y + towerSize <= 800;
}

void TowerDefens::renderCircle(SDL_Renderer* renderer, int centerX, int centerY, int radius) {
    for (int w = 0; w < radius * 2; ++w) {
        for (int h = 0; h < radius * 2; ++h) {
            int dx = radius - w;
            int dy = radius - h;
            if ((dx * dx + dy * dy) <= (radius * radius)) {
                SDL_RenderDrawPoint(renderer, centerX + dx, centerY + dy);
            }
        }
    }
}


settings.h
#ifndef SETTINGS_H
#define SETTINGS_H
#include "../common/common.h"

class Settings {
public:
    Settings();
    ~Settings();
    void init(SDL_Renderer* renderer, TTF_Font* font);
    void handleEvents(SDL_Event& event, int& scene, int mx, int my);
    void render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my);

private:
    SDL_Rect volumeSliderTrack;
    SDL_Rect volumeSliderHandle;
    SDL_Rect backButton;
    bool isDraggingSlider;
    SDL_Color sliderTrackColor;
    SDL_Color sliderHandleColor;
    SDL_Color sliderActiveColor;
    bool isMouseOnButton(int mx, int my, const SDL_Rect& button);
};

#endif

settings.cpp
#include "settings.h"
#include <iostream>

Settings::Settings() : volumeSliderTrack({300, 350, 200, 10}), volumeSliderHandle({300, 345, 10, 20}),
    backButton({650, 650, 120, 60}), isDraggingSlider(false),
    sliderTrackColor({100, 100, 100, 255}), sliderHandleColor({150, 150, 150, 255}),
    sliderActiveColor({80, 80, 120, 255}) {}

Settings::~Settings() {}

void Settings::init(SDL_Renderer* renderer, TTF_Font* font) {
    int volume = Mix_VolumeMusic(-1);
    float progress = static_cast<float>(volume) / MIX_MAX_VOLUME;
    volumeSliderHandle.x = volumeSliderTrack.x + static_cast<int>(progress * (volumeSliderTrack.w - volumeSliderHandle.w));
}

void Settings::handleEvents(SDL_Event& event, int& scene, int mx, int my) {
    bool mouseOnSlider = isMouseOnButton(mx, my, volumeSliderHandle);
    bool mouseOnBack = isMouseOnButton(mx, my, backButton);

    if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT) {
        if (mouseOnSlider) {
            isDraggingSlider = true;
        } else if (mouseOnBack) {
            scene = -1; // Вернуться в главное меню
        }
    } else if (event.type == SDL_MOUSEBUTTONUP && event.button.button == SDL_BUTTON_LEFT) {
        isDraggingSlider = false;
    } else if (event.type == SDL_MOUSEMOTION && isDraggingSlider) {
        int newX = mx - volumeSliderHandle.w / 2;
        if (newX < volumeSliderTrack.x) newX = volumeSliderTrack.x;
        if (newX > volumeSliderTrack.x + volumeSliderTrack.w - volumeSliderHandle.w) newX = volumeSliderTrack.x + volumeSliderTrack.w - volumeSliderHandle.w;
        volumeSliderHandle.x = newX;
        float progress = static_cast<float>(volumeSliderHandle.x - volumeSliderTrack.x) / (volumeSliderTrack.w - volumeSliderHandle.w);
        int volume = static_cast<int>(progress * MIX_MAX_VOLUME);
        Mix_VolumeMusic(volume);
    }
}

void Settings::render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my) {
    bool mouseOnBack = isMouseOnButton(mx, my, backButton);

    // Рендеринг ползунка громкости
    SDL_SetRenderDrawColor(renderer, sliderTrackColor.r, sliderTrackColor.g, sliderTrackColor.b, sliderTrackColor.a);
    SDL_RenderFillRect(renderer, &volumeSliderTrack);
    int handlePos = volumeSliderHandle.x - volumeSliderTrack.x;
    SDL_Rect activePart = {volumeSliderTrack.x, volumeSliderTrack.y, handlePos + volumeSliderHandle.w / 2, volumeSliderTrack.h};
    SDL_SetRenderDrawColor(renderer, sliderActiveColor.r, sliderActiveColor.g, sliderActiveColor.b, sliderActiveColor.a);
    SDL_RenderFillRect(renderer, &activePart);
    SDL_SetRenderDrawColor(renderer, sliderHandleColor.r, sliderHandleColor.g, sliderHandleColor.b, sliderHandleColor.a);
    SDL_RenderFillRect(renderer, &volumeSliderHandle);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &volumeSliderHandle);

    // Рендеринг текста громкости
    SDL_Texture* volumeText = createTextTexture(renderer, font, "Громкость", textColor, 180);
    if (volumeText) {
        int tw, th;
        SDL_QueryTexture(volumeText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {volumeSliderTrack.x + (volumeSliderTrack.w - tw) / 2, volumeSliderTrack.y - th - 10, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(volumeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(volumeText, shadowColor.a);
        SDL_RenderCopy(renderer, volumeText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(volumeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(volumeText, 255);
        SDL_RenderCopy(renderer, volumeText, nullptr, &tr);
        SDL_DestroyTexture(volumeText);
    }

    // Рендеринг кнопки "Назад"
    SDL_SetRenderDrawColor(renderer, mouseOnBack ? buttonHoverColor.r : buttonColor.r,
        mouseOnBack ? buttonHoverColor.g : buttonColor.g,
        mouseOnBack ? buttonHoverColor.b : buttonColor.b, 255);
    SDL_Rect scaledBackButton = {backButton.x - (mouseOnBack ? 5 : 0), backButton.y - (mouseOnBack ? 5 : 0),
        backButton.w + (mouseOnBack ? 10 : 0), backButton.h + (mouseOnBack ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledBackButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledBackButton);

    SDL_Texture* backText = createTextTexture(renderer, font, "Назад", textColor, 100);
    if (backText) {
        int tw, th;
        SDL_QueryTexture(backText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledBackButton.x + (scaledBackButton.w - tw) / 2, scaledBackButton.y + (scaledBackButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(backText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(backText, shadowColor.a);
        SDL_RenderCopy(renderer, backText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(backText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(backText, 255);
        SDL_RenderCopy(renderer, backText, nullptr, &tr);
        SDL_DestroyTexture(backText);
    }
}

bool Settings::isMouseOnButton(int mx, int my, const SDL_Rect& button) {
    SDL_Rect cursor = {mx, my, 2, 2};
    return SDL_HasIntersection(&cursor, &button);
}


musicPlayer.h
#ifndef MUSICPLAYER_H
#define MUSICPLAYER_H
#include "../common/common.h"
#include "../biblioteki/tinyfiledialogs.h"
#include <string>
#include <vector>

class MusicPlayer {
public:
    MusicPlayer();
    ~MusicPlayer();
    void init(const std::string& initialMusicPath, const std::string& initialFolderPath);
    void handleEvents(SDL_Event& event, SDL_Renderer* renderer, TTF_Font* font, TTF_Font* trackFont, int mx, int my, bool& running, int& scene);
    void update(SDL_Renderer* renderer, TTF_Font* font);
    void render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my);

private:
    std::string musicPath;
    std::string folderPath;
    std::string currentTrack;
    std::string coverPath;
    std::vector<std::string> musicFiles;
    std::vector<SDL_Texture*> musicFileTextures;
    std::vector<SDL_Rect> musicSquares;
    Mix_Music* bgm;
    int currentTrackIndex;
    bool musicStarted;
    SDL_Texture* trackText;
    SDL_Texture* currentTimeText;
    SDL_Texture* totalTimeText;
    SDL_Texture* hoverTimeText;
    SDL_Texture* coverTexture;
    double musicDuration;
    bool needsScrolling;
    int textOffset;
    Uint32 lastTextUpdate;
    SDL_Rect coverRect;
    SDL_Rect knopka1;
    SDL_Rect knopka2;
    SDL_Rect knopka11;
    SDL_Rect backButton;
    SDL_Rect sliderTrack;
    SDL_Rect sliderHandle;
    bool isDraggingSlider;
    SDL_Rect musicScrollTrack;
    SDL_Rect musicScrollHandle;
    bool isDraggingMusicScroll;
    size_t musicScrollOffset;
    size_t maxVisibleSquares;
    SDL_Color textColor;
    SDL_Color shadowColor;
    SDL_Color buttonColor;
    SDL_Color buttonHoverColor;
    SDL_Color borderColor;
    SDL_Color sliderTrackColor;
    SDL_Color sliderHandleColor;
    SDL_Color sliderActiveColor;
    bool isMouseOnButton(int mx, int my, const SDL_Rect& button);
};

#endif

musicPlayer.cpp
#include "musicPlayer.h"
#include <iostream>
#include <fstream>
#include <filesystem>

using namespace std;
namespace fs = filesystem;

MusicPlayer::MusicPlayer() : musicPath("music/muzika.mp3"), bgm(nullptr), currentTrackIndex(0), musicStarted(false),
    trackText(nullptr), currentTimeText(nullptr), totalTimeText(nullptr), hoverTimeText(nullptr),
    coverTexture(nullptr), musicDuration(0.0), needsScrolling(false), textOffset(0), lastTextUpdate(0),
    coverRect({300, 100, 200, 200}), knopka1({0, 0, 200, 75}), knopka2({0, 75, 200, 75}),
    knopka11({340, 550, 120, 75}), backButton({650, 650, 120, 60}),
    sliderTrack({300, 500, 200, 10}), sliderHandle({300, 495, 10, 20}),
    isDraggingSlider(false), musicScrollTrack({790, 50, 10, 385}), musicScrollHandle({790, 50, 10, 20}),
    isDraggingMusicScroll(false), musicScrollOffset(0), maxVisibleSquares(7),
    textColor({200, 200, 200, 255}), shadowColor({50, 50, 50, 100}),
    buttonColor({40, 40, 60, 255}), buttonHoverColor({60, 60, 90, 255}),
    borderColor({100, 100, 100, 255}), sliderTrackColor({100, 100, 100, 255}),
    sliderHandleColor({150, 150, 150, 255}), sliderActiveColor({80, 80, 120, 255}) {}

MusicPlayer::~MusicPlayer() {
    if (bgm) Mix_FreeMusic(bgm);
    if (trackText) SDL_DestroyTexture(trackText);
    if (currentTimeText) SDL_DestroyTexture(currentTimeText);
    if (totalTimeText) SDL_DestroyTexture(totalTimeText);
    if (hoverTimeText) SDL_DestroyTexture(hoverTimeText);
    if (coverTexture) SDL_DestroyTexture(coverTexture);
    for (auto& texture : musicFileTextures) {
        if (texture) SDL_DestroyTexture(texture);
    }
}

void MusicPlayer::init(const string& initialMusicPath, const string& initialFolderPath) {
    musicPath = initialMusicPath;
    folderPath = initialFolderPath;
    if (!folderPath.empty() && fs::exists(folderPath)) {
        for (const auto& entry : fs::directory_iterator(folderPath)) {
            if (entry.path().extension() == ".mp3" || entry.path().extension() == ".wav") {
                musicFiles.push_back(entry.path().string());
                if (entry.path().string() == musicPath) {
                    currentTrackIndex = musicFiles.size() - 1;
                }
            }
        }
    }
    bgm = Mix_LoadMUS(musicPath.c_str());
    if (!bgm) {
        cerr << "Ошибка загрузки музыки: " << Mix_GetError() << endl;
    }
    musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
    currentTrack = fs::path(musicPath).filename().string();
    needsScrolling = currentTrack.length() > 15;
    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
}

void MusicPlayer::handleEvents(SDL_Event& event, SDL_Renderer* renderer, TTF_Font* font, TTF_Font* trackFont, int mx, int my, bool& running, int& scene) {
    bool MouseOnKnopka1 = isMouseOnButton(mx, my, knopka1);
    bool MouseOnKnopka2 = isMouseOnButton(mx, my, knopka2);
    bool MouseOnKnopka11 = isMouseOnButton(mx, my, knopka11);
    bool MouseOnBack = isMouseOnButton(mx, my, backButton);
    bool MouseOnSlider = isMouseOnButton(mx, my, sliderHandle);
    bool MouseOnSliderTrack = (mx >= sliderTrack.x && mx <= sliderTrack.x + sliderTrack.w && my >= sliderTrack.y && my <= sliderTrack.y + sliderTrack.h);
    bool MouseOnMusicScroll = isMouseOnButton(mx, my, musicScrollHandle);
    bool MouseOnCover = isMouseOnButton(mx, my, coverRect);
    vector<bool> MouseOnMusicSquare(musicSquares.size(), false);
    for (size_t i = 0; i < musicSquares.size(); ++i) {
        MouseOnMusicSquare[i] = isMouseOnButton(mx, my, musicSquares[i]);
    }

    if (event.type == SDL_KEYDOWN) {
        if (event.key.keysym.sym == SDLK_1 && bgm && !musicStarted) {
            if (Mix_PlayMusic(bgm, -1) == -1) {
                cerr << "Ошибка воспроизведения музыки: " << Mix_GetError() << endl;
            } else {
                musicStarted = true;
            }
        } else if (event.key.keysym.sym == SDLK_SPACE) {
            if (Mix_PausedMusic()) {
                Mix_ResumeMusic();
            } else {
                Mix_PauseMusic();
            }
        } else if (event.key.keysym.sym == SDLK_UP && !musicFiles.empty()) {
            if (currentTrackIndex > 0) {
                currentTrackIndex--;
            } else {
                currentTrackIndex = musicFiles.size() - 1;
            }
            musicPath = musicFiles[currentTrackIndex];
            if (musicStarted) {
                Mix_HaltMusic();
                musicStarted = false;
            }
            if (bgm) {
                Mix_FreeMusic(bgm);
            }
            bgm = Mix_LoadMUS(musicPath.c_str());
            if (!bgm) {
                cerr << "Ошибка загрузки новой музыки: " << Mix_GetError() << endl;
            } else {
                if (Mix_PlayMusic(bgm, -1) == -1) {
                    cerr << "Ошибка воспроизведения музыки: " << Mix_GetError() << endl;
                } else {
                    musicStarted = true;
                }
            }
            if (trackText) SDL_DestroyTexture(trackText);
            currentTrack = fs::path(musicPath).filename().string();
            trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
            needsScrolling = currentTrack.length() > 15;
            textOffset = 0;
            if (totalTimeText) SDL_DestroyTexture(totalTimeText);
            musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
            totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
            if (coverTexture) SDL_DestroyTexture(coverTexture);
            coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
            if (fs::exists(coverPath)) {
                SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                if (coverSurface) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                    SDL_FreeSurface(coverSurface);
                }
            } else {
                SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                if (defaultCover) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                    SDL_FreeSurface(defaultCover);
                }
            }
            ofstream outFile("save/music_path.txt");
            if (outFile.is_open()) {
                outFile << musicPath << "\n" << folderPath;
                outFile.close();
            }
        } else if (event.key.keysym.sym == SDLK_DOWN && !musicFiles.empty()) {
            if (currentTrackIndex < static_cast<int>(musicFiles.size()) - 1) {
                currentTrackIndex++;
            } else {
                currentTrackIndex = 0;
            }
            musicPath = musicFiles[currentTrackIndex];
            if (musicStarted) {
                Mix_HaltMusic();
                musicStarted = false;
            }
            if (bgm) {
                Mix_FreeMusic(bgm);
            }
            bgm = Mix_LoadMUS(musicPath.c_str());
            if (!bgm) {
                cerr << "Ошибка загрузки новой музыки: " << Mix_GetError() << endl;
            } else {
                if (Mix_PlayMusic(bgm, -1) == -1) {
                    cerr << "Ошибка воспроизведения музыки: " << Mix_GetError() << endl;
                } else {
                    musicStarted = true;
                }
            }
            if (trackText) SDL_DestroyTexture(trackText);
            currentTrack = fs::path(musicPath).filename().string();
            trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
            needsScrolling = currentTrack.length() > 15;
            textOffset = 0;
            if (totalTimeText) SDL_DestroyTexture(totalTimeText);
            musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
            totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
            if (coverTexture) SDL_DestroyTexture(coverTexture);
            coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
            if (fs::exists(coverPath)) {
                SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                if (coverSurface) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                    SDL_FreeSurface(coverSurface);
                }
            } else {
                SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                if (defaultCover) {
                    coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                    SDL_FreeSurface(defaultCover);
                }
            }
            ofstream outFile("save/music_path.txt");
            if (outFile.is_open()) {
                outFile << musicPath << "\n" << folderPath;
                outFile.close();
            }
        } else if (event.key.keysym.sym == SDLK_LEFT && bgm && musicStarted) {
            double currentPosition = Mix_GetMusicPosition(bgm);
            double newPosition = max(0.0, currentPosition - 5.0);
            Mix_SetMusicPosition(newPosition);
        } else if (event.key.keysym.sym == SDLK_RIGHT && bgm && musicStarted) {
            double currentPosition = Mix_GetMusicPosition(bgm);
            double musicDuration = Mix_MusicDuration(bgm);
            double newPosition = min(musicDuration, currentPosition + 5.0);
            Mix_SetMusicPosition(newPosition);
        }
    } else if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT) {
        if (MouseOnKnopka1) {
            const char* selectedFolder = tinyfd_selectFolderDialog("Выберите папку с музыкой", "");
            if (selectedFolder) {
                folderPath = selectedFolder;
                musicFiles.clear();
                musicSquares.clear();
                for (auto& texture : musicFileTextures) {
                    if (texture) SDL_DestroyTexture(texture);
                }
                musicFileTextures.clear();
                currentTrackIndex = 0;
                for (const auto& entry : fs::directory_iterator(folderPath)) {
                    if (entry.path().extension() == ".mp3" || entry.path().extension() == ".wav") {
                        musicFiles.push_back(entry.path().string());
                        string filename = fs::path(entry.path()).filename().string();
                        SDL_Texture* textTexture = createTextTexture(renderer, font, filename, textColor, 130);
                        musicFileTextures.push_back(textTexture);
                    }
                }
                musicScrollOffset = 0;
                musicSquares.clear();
                for (size_t i = 0; i < musicFiles.size() && i < maxVisibleSquares; ++i) {
                    musicSquares.push_back({650, static_cast<int>(50 + i * 55), 140, 50});
                }
                if (!musicFiles.empty()) {
                    musicPath = musicFiles[0];
                    if (musicStarted) {
                        Mix_HaltMusic();
                        musicStarted = false;
                    }
                    if (bgm) {
                        Mix_FreeMusic(bgm);
                    }
                    bgm = Mix_LoadMUS(musicPath.c_str());
                    if (trackText) SDL_DestroyTexture(trackText);
                    currentTrack = fs::path(musicPath).filename().string();
                    trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
                    needsScrolling = currentTrack.length() > 15;
                    textOffset = 0;
                    if (totalTimeText) SDL_DestroyTexture(totalTimeText);
                    musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
                    totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
                    if (coverTexture) SDL_DestroyTexture(coverTexture);
                    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
                    if (fs::exists(coverPath)) {
                        SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                        if (coverSurface) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                            SDL_FreeSurface(coverSurface);
                        }
                    } else {
                        SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                        if (defaultCover) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                            SDL_FreeSurface(defaultCover);
                        }
                    }
                }
                ofstream outFile("save/music_path.txt");
                if (outFile.is_open()) {
                    outFile << musicPath << "\n" << folderPath;
                    outFile.close();
                }
            }
        } else if (MouseOnKnopka2) {
            running = false;
        } else if (MouseOnKnopka11) {
            if (Mix_PausedMusic()) {
                Mix_ResumeMusic();
            } else {
                Mix_PauseMusic();
            }
        } else if (MouseOnBack) {
            scene = -1; // Вернуться в главное меню
        } else if (MouseOnSlider) {
            isDraggingSlider = true;
        } else if (MouseOnMusicScroll) {
            isDraggingMusicScroll = true;
        } else if (MouseOnSliderTrack && bgm) {
            double musicDuration = Mix_MusicDuration(bgm);
            if (musicDuration > 0) {
                float progress = static_cast<float>(mx - sliderTrack.x) / sliderTrack.w;
                double newPosition = progress * musicDuration;
                Mix_SetMusicPosition(newPosition);
            }
        } else if (MouseOnCover) {
            const char* selectedImage = tinyfd_openFileDialog("Выберите обложку", "", 0, nullptr, nullptr, 0);
            if (selectedImage) {
                SDL_Surface* newCoverSurface = IMG_Load(selectedImage);
                if (newCoverSurface) {
                    if (coverTexture) SDL_DestroyTexture(coverTexture);
                    coverTexture = SDL_CreateTextureFromSurface(renderer, newCoverSurface);
                    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
                    IMG_SavePNG(newCoverSurface, coverPath.c_str());
                    SDL_FreeSurface(newCoverSurface);
                }
            }
        } else {
            for (size_t i = 0; i < musicSquares.size(); ++i) {
                if (MouseOnMusicSquare[i] && i + musicScrollOffset < musicFiles.size()) {
                    currentTrackIndex = i + musicScrollOffset;
                    musicPath = musicFiles[currentTrackIndex];
                    if (musicStarted) {
                        Mix_HaltMusic();
                        musicStarted = false;
                    }
                    if (bgm) {
                        Mix_FreeMusic(bgm);
                    }
                    bgm = Mix_LoadMUS(musicPath.c_str());
                    if (!bgm) {
                        cerr << "Ошибка загрузки новой музыки: " << Mix_GetError() << endl;
                    } else {
                        if (Mix_PlayMusic(bgm, -1) == -1) {
                            cerr << "Ошибка воспроизведения музыки: " << Mix_GetError() << endl;
                        } else {
                            musicStarted = true;
                        }
                    }
                    if (trackText) SDL_DestroyTexture(trackText);
                    currentTrack = fs::path(musicPath).filename().string();
                    trackText = createTextTexture(renderer, trackFont, currentTrack.length() > 15 ? currentTrack.substr(0, 15) + "..." : currentTrack, textColor);
                    needsScrolling = currentTrack.length() > 15;
                    textOffset = 0;
                    if (totalTimeText) SDL_DestroyTexture(totalTimeText);
                    musicDuration = bgm ? Mix_MusicDuration(bgm) : 0.0;
                    totalTimeText = createTextTexture(renderer, font, formatTime(musicDuration), textColor);
                    if (coverTexture) SDL_DestroyTexture(coverTexture);
                    coverPath = "img/cover_" + fs::path(musicPath).stem().string() + ".png";
                    if (fs::exists(coverPath)) {
                        SDL_Surface* coverSurface = IMG_Load(coverPath.c_str());
                        if (coverSurface) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, coverSurface);
                            SDL_FreeSurface(coverSurface);
                        }
                    } else {
                        SDL_Surface* defaultCover = IMG_Load("img/ZnakMuziki.png");
                        if (defaultCover) {
                            coverTexture = SDL_CreateTextureFromSurface(renderer, defaultCover);
                            SDL_FreeSurface(defaultCover);
                        }
                    }
                    ofstream outFile("save/music_path.txt");
                    if (outFile.is_open()) {
                        outFile << musicPath << "\n" << folderPath;
                        outFile.close();
                    }
                    break;
                }
            }
        }
    } else if (event.type == SDL_MOUSEBUTTONUP && event.button.button == SDL_BUTTON_LEFT) {
        if (isDraggingSlider) {
            isDraggingSlider = false;
            if (bgm && musicStarted) {
                double musicDuration = Mix_MusicDuration(bgm);
                if (musicDuration > 0) {
                    float progress = static_cast<float>(sliderHandle.x - sliderTrack.x) / (sliderTrack.w - sliderHandle.w);
                    double newPosition = progress * musicDuration;
                    Mix_SetMusicPosition(newPosition);
                }
            }
        } else if (isDraggingMusicScroll) {
            isDraggingMusicScroll = false;
        }
    } else if (event.type == SDL_MOUSEMOTION) {
        if (isDraggingSlider) {
            int newX = mx - sliderHandle.w / 2;
            if (newX < sliderTrack.x) newX = sliderTrack.x;
            if (newX > sliderTrack.x + sliderTrack.w - sliderHandle.w) newX = sliderTrack.x + sliderTrack.w - sliderHandle.w;
            sliderHandle.x = newX;
        } else if (isDraggingMusicScroll && musicFiles.size() > maxVisibleSquares) {
            int newY = my - musicScrollHandle.h / 2;
            if (newY < musicScrollTrack.y) newY = musicScrollTrack.y;
            if (newY > musicScrollTrack.y + musicScrollTrack.h - musicScrollHandle.h) newY = musicScrollTrack.y + musicScrollTrack.h - musicScrollHandle.h;
            musicScrollHandle.y = newY;
            float progress = static_cast<float>(musicScrollHandle.y - musicScrollTrack.y) / (musicScrollTrack.h - musicScrollHandle.h);
            musicScrollOffset = static_cast<size_t>(progress * (musicFiles.size() - maxVisibleSquares));
            musicSquares.clear();
            for (size_t i = musicScrollOffset; i < musicFiles.size() && i < musicScrollOffset + maxVisibleSquares; ++i) {
                musicSquares.push_back({650, static_cast<int>(50 + (i - musicScrollOffset) * 55), 140, 50});
            }
        }
    }
}

void MusicPlayer::update(SDL_Renderer* renderer, TTF_Font* font) {
    if (bgm && musicStarted && !isDraggingSlider) {
        double currentPosition = Mix_GetMusicPosition(bgm);
        if (musicDuration > 0) {
            float progress = static_cast<float>(currentPosition) / musicDuration;
            sliderHandle.x = sliderTrack.x + static_cast<int>(progress * (sliderTrack.w - sliderHandle.w));
        }
        if (currentTimeText) SDL_DestroyTexture(currentTimeText);
        currentTimeText = createTextTexture(renderer, font, formatTime(currentPosition), textColor);
    }
    if (needsScrolling) {
        Uint32 currentTime = SDL_GetTicks();
        if (currentTime - lastTextUpdate >= 50) {
            textOffset++;
            int textW, textH;
            SDL_QueryTexture(trackText, nullptr, nullptr, &textW, &textH);
            if (textOffset >= textW - 300) {
                textOffset = 0;
            }
            lastTextUpdate = currentTime;
        }
    } else {
        textOffset = 0;
    }
    if (!isDraggingMusicScroll && musicFiles.size() > maxVisibleSquares) {
        float progress = static_cast<float>(musicScrollOffset) / (musicFiles.size() - maxVisibleSquares);
        musicScrollHandle.y = musicScrollTrack.y + static_cast<int>(progress * (musicScrollTrack.h - musicScrollHandle.h));
    }
}

void MusicPlayer::render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my) {
    bool MouseOnKnopka1 = isMouseOnButton(mx, my, knopka1);
    bool MouseOnKnopka2 = isMouseOnButton(mx, my, knopka2);
    bool MouseOnKnopka11 = isMouseOnButton(mx, my, knopka11);
    bool MouseOnBack = isMouseOnButton(mx, my, backButton);
    bool MouseOnSliderTrack = (mx >= sliderTrack.x && mx <= sliderTrack.x + sliderTrack.w && my >= sliderTrack.y && my <= sliderTrack.y + sliderTrack.h);
    bool MouseOnMusicScroll = isMouseOnButton(mx, my, musicScrollHandle);
    vector<bool> MouseOnMusicSquare(musicSquares.size(), false);
    for (size_t i = 0; i < musicSquares.size(); ++i) {
        MouseOnMusicSquare[i] = isMouseOnButton(mx, my, musicSquares[i]);
    }

    SDL_Rect shadowRect = {coverRect.x + 5, coverRect.y + 5, coverRect.w, coverRect.h};
    SDL_SetRenderDrawColor(renderer, shadowColor.r, shadowColor.g, shadowColor.b, shadowColor.a);
    SDL_RenderFillRect(renderer, &shadowRect);
    SDL_SetRenderDrawColor(renderer, buttonColor.r, buttonColor.g, buttonColor.b, buttonColor.a);
    SDL_RenderFillRect(renderer, &coverRect);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &coverRect);
    if (coverTexture) {
        SDL_RenderCopy(renderer, coverTexture, nullptr, &coverRect);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnKnopka1 ? buttonHoverColor.r : buttonColor.r, MouseOnKnopka1 ? buttonHoverColor.g : buttonColor.g, MouseOnKnopka1 ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_Rect scaledKnopka1 = {knopka1.x - (MouseOnKnopka1 ? 5 : 0), knopka1.y - (MouseOnKnopka1 ? 5 : 0),
        knopka1.w + (MouseOnKnopka1 ? 10 : 0), knopka1.h + (MouseOnKnopka1 ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledKnopka1);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledKnopka1);
    SDL_Texture* btn1Text = createTextTexture(renderer, font, "Выбрать папку", textColor, 180);
    if (btn1Text) {
        int tw, th;
        SDL_QueryTexture(btn1Text, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledKnopka1.x + (scaledKnopka1.w - tw) / 2, scaledKnopka1.y + (scaledKnopka1.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(btn1Text, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(btn1Text, shadowColor.a);
        SDL_RenderCopy(renderer, btn1Text, nullptr, &shadowTr);
        SDL_SetTextureColorMod(btn1Text, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(btn1Text, 255);
        SDL_RenderCopy(renderer, btn1Text, nullptr, &tr);
        SDL_DestroyTexture(btn1Text);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnKnopka2 ? buttonHoverColor.r : buttonColor.r, MouseOnKnopka2 ? buttonHoverColor.g : buttonColor.g, MouseOnKnopka2 ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_Rect scaledKnopka2 = {knopka2.x - (MouseOnKnopka2 ? 5 : 0), knopka2.y - (MouseOnKnopka2 ? 5 : 0),
        knopka2.w + (MouseOnKnopka2 ? 10 : 0), knopka2.h + (MouseOnKnopka2 ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledKnopka2);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledKnopka2);
    SDL_Texture* btn2Text = createTextTexture(renderer, font, "Выход", textColor, 180);
    if (btn2Text) {
        int tw, th;
        SDL_QueryTexture(btn2Text, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledKnopka2.x + (scaledKnopka2.w - tw) / 2, scaledKnopka2.y + (scaledKnopka2.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(btn2Text, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(btn2Text, shadowColor.a);
        SDL_RenderCopy(renderer, btn2Text, nullptr, &shadowTr);
        SDL_SetTextureColorMod(btn2Text, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(btn2Text, 255);
        SDL_RenderCopy(renderer, btn2Text, nullptr, &tr);
        SDL_DestroyTexture(btn2Text);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnKnopka11 ? buttonHoverColor.r : buttonColor.r, MouseOnKnopka11 ? buttonHoverColor.g : buttonColor.g, MouseOnKnopka11 ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_Rect scaledKnopka11 = {knopka11.x - (MouseOnKnopka11 ? 5 : 0), knopka11.y - (MouseOnKnopka11 ? 5 : 0),
        knopka11.w + (MouseOnKnopka11 ? 10 : 0), knopka11.h + (MouseOnKnopka11 ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledKnopka11);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledKnopka11);
    SDL_Texture* btn11Text = createTextTexture(renderer, font, Mix_PausedMusic() ? "Играть" : "Пауза", textColor, 100);
    if (btn11Text) {
        int tw, th;
        SDL_QueryTexture(btn11Text, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledKnopka11.x + (scaledKnopka11.w - tw) / 2, scaledKnopka11.y + (scaledKnopka11.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(btn11Text, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(btn11Text, shadowColor.a);
        SDL_RenderCopy(renderer, btn11Text, nullptr, &shadowTr);
        SDL_SetTextureColorMod(btn11Text, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(btn11Text, 255);
        SDL_RenderCopy(renderer, btn11Text, nullptr, &tr);
        SDL_DestroyTexture(btn11Text);
    }
    SDL_SetRenderDrawColor(renderer, MouseOnBack ? buttonHoverColor.r : buttonColor.r, MouseOnBack ? buttonHoverColor.g : buttonColor.g, MouseOnBack ? buttonHoverColor.b : buttonHoverColor.b, 255);
    SDL_Rect scaledBackButton = {backButton.x - (MouseOnBack ? 5 : 0), backButton.y - (MouseOnBack ? 5 : 0),
        backButton.w + (MouseOnBack ? 10 : 0), backButton.h + (MouseOnBack ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledBackButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledBackButton);
    SDL_Texture* backText = createTextTexture(renderer, font, "Назад", textColor, 100);
    if (backText) {
        int tw, th;
        SDL_QueryTexture(backText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledBackButton.x + (scaledBackButton.w - tw) / 2, scaledBackButton.y + (scaledBackButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(backText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(backText, shadowColor.a);
        SDL_RenderCopy(renderer, backText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(backText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(backText, 255);
        SDL_RenderCopy(renderer, backText, nullptr, &tr);
        SDL_DestroyTexture(backText);
    }
    if (trackText) {
        int textW, textH;
        SDL_QueryTexture(trackText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {300 - textOffset, 350, min(textW, 300), textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textRect.w, textRect.h};
        SDL_Rect clipRect = {300, 350, 300, textH};
        SDL_RenderSetClipRect(renderer, &clipRect);
        SDL_SetTextureColorMod(trackText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(trackText, shadowColor.a);
        SDL_RenderCopy(renderer, trackText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(trackText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(trackText, 255);
        SDL_RenderCopy(renderer, trackText, nullptr, &textRect);
        SDL_RenderSetClipRect(renderer, nullptr);
    }
    SDL_SetRenderDrawColor(renderer, sliderTrackColor.r, sliderTrackColor.g, sliderTrackColor.b, sliderTrackColor.a);
    SDL_RenderFillRect(renderer, &sliderTrack);
    int handlePos = sliderHandle.x - sliderTrack.x;
    SDL_Rect activePart = {sliderTrack.x, sliderTrack.y, handlePos + sliderHandle.w / 2, sliderTrack.h};
    SDL_SetRenderDrawColor(renderer, sliderActiveColor.r, sliderActiveColor.g, sliderActiveColor.b, sliderActiveColor.a);
    SDL_RenderFillRect(renderer, &activePart);
    SDL_SetRenderDrawColor(renderer, sliderHandleColor.r, sliderHandleColor.g, sliderHandleColor.b, sliderHandleColor.a);
    SDL_RenderFillRect(renderer, &sliderHandle);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &sliderHandle);
    if (currentTimeText) {
        int textW, textH;
        SDL_QueryTexture(currentTimeText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {sliderTrack.x - textW - 5, sliderTrack.y - textH / 2, textW, textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
        SDL_SetTextureColorMod(currentTimeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(currentTimeText, shadowColor.a);
        SDL_RenderCopy(renderer, currentTimeText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(currentTimeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(currentTimeText, 255);
        SDL_RenderCopy(renderer, currentTimeText, nullptr, &textRect);
    }
    if (totalTimeText) {
        int textW, textH;
        SDL_QueryTexture(totalTimeText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {sliderTrack.x + sliderTrack.w + 5, sliderTrack.y - textH / 2, textW, textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
        SDL_SetTextureColorMod(totalTimeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(totalTimeText, shadowColor.a);
        SDL_RenderCopy(renderer, totalTimeText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(totalTimeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(totalTimeText, 255);
        SDL_RenderCopy(renderer, totalTimeText, nullptr, &textRect);
    }
    if (MouseOnSliderTrack && bgm) {
        if (hoverTimeText) SDL_DestroyTexture(hoverTimeText);
        double musicDuration = Mix_MusicDuration(bgm);
        if (musicDuration > 0) {
            float progress = static_cast<float>(mx - sliderTrack.x) / sliderTrack.w;
            double hoverPosition = progress * musicDuration;
            hoverTimeText = createTextTexture(renderer, font, formatTime(hoverPosition), textColor);
        }
    } else {
        if (hoverTimeText) SDL_DestroyTexture(hoverTimeText);
        hoverTimeText = nullptr;
    }
    if (hoverTimeText) {
        int textW, textH;
        SDL_QueryTexture(hoverTimeText, nullptr, nullptr, &textW, &textH);
        SDL_Rect textRect = {mx - textW / 2, my - textH - 5, textW, textH};
        SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
        SDL_SetTextureColorMod(hoverTimeText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(hoverTimeText, shadowColor.a);
        SDL_RenderCopy(renderer, hoverTimeText, nullptr, &shadowRect);
        SDL_SetTextureColorMod(hoverTimeText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(hoverTimeText, 255);
        SDL_RenderCopy(renderer, hoverTimeText, nullptr, &textRect);
    }
    SDL_SetRenderDrawColor(renderer, sliderTrackColor.r, sliderTrackColor.g, sliderTrackColor.b, sliderTrackColor.a);
    SDL_RenderFillRect(renderer, &musicScrollTrack);
    SDL_SetRenderDrawColor(renderer, MouseOnMusicScroll ? sliderActiveColor.r : sliderHandleColor.r, MouseOnMusicScroll ? sliderActiveColor.g : sliderHandleColor.g, MouseOnMusicScroll ? sliderActiveColor.b : sliderHandleColor.b, 255);
    SDL_RenderFillRect(renderer, &musicScrollHandle);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &musicScrollHandle);
    for (size_t i = 0; i < musicSquares.size(); ++i) {
        SDL_SetRenderDrawColor(renderer, MouseOnMusicSquare[i] ? buttonHoverColor.r : buttonColor.r, MouseOnMusicSquare[i] ? buttonHoverColor.g : buttonColor.g, MouseOnMusicSquare[i] ? buttonHoverColor.b : buttonHoverColor.b, 255);
        SDL_Rect scaledSquare = {musicSquares[i].x - (MouseOnMusicSquare[i] ? 5 : 0), musicSquares[i].y - (MouseOnMusicSquare[i] ? 5 : 0),
            musicSquares[i].w + (MouseOnMusicSquare[i] ? 10 : 0), musicSquares[i].h + (MouseOnMusicSquare[i] ? 10 : 0)};
        SDL_RenderFillRect(renderer, &scaledSquare);
        SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
        SDL_RenderDrawRect(renderer, &scaledSquare);
        if (i + musicScrollOffset < musicFileTextures.size() && musicFileTextures[i + musicScrollOffset]) {
            int textW, textH;
            SDL_QueryTexture(musicFileTextures[i + musicScrollOffset], nullptr, nullptr, &textW, &textH);
            SDL_Rect textRect = {scaledSquare.x + 5, scaledSquare.y + (scaledSquare.h - textH) / 2, textW, textH};
            SDL_Rect shadowRect = {textRect.x + 2, textRect.y + 2, textW, textH};
            SDL_Rect clipRect = {scaledSquare.x + 5, scaledSquare.y, 130, scaledSquare.h};
            SDL_RenderSetClipRect(renderer, &clipRect);
            SDL_SetTextureColorMod(musicFileTextures[i + musicScrollOffset], shadowColor.r, shadowColor.g, shadowColor.b);
            SDL_SetTextureAlphaMod(musicFileTextures[i + musicScrollOffset], shadowColor.a);
            SDL_RenderCopy(renderer, musicFileTextures[i + musicScrollOffset], nullptr, &shadowRect);
            SDL_SetTextureColorMod(musicFileTextures[i + musicScrollOffset], textColor.r, textColor.g, textColor.b);
            SDL_SetTextureAlphaMod(musicFileTextures[i + musicScrollOffset], 255);
            SDL_RenderCopy(renderer, musicFileTextures[i + musicScrollOffset], nullptr, &textRect);
            SDL_RenderSetClipRect(renderer, nullptr);
        }
    }
}

bool MusicPlayer::isMouseOnButton(int mx, int my, const SDL_Rect& button) {
    SDL_Rect cursor = {mx, my, 2, 2};
    return SDL_HasIntersection(&cursor, &button);
}


mainMenu.h
#ifndef MAINMENU_H
#define MAINMENU_H
#include "../common/common.h"
#include <vector>

class MainMenu {
public:
    MainMenu();
    ~MainMenu();
    void init(SDL_Renderer* renderer, TTF_Font* font);
    void handleEvents(SDL_Event& event, int& scene, bool& running, int mx, int my);
    void render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my);

private:
    SDL_Rect playerButton;
    SDL_Rect gameButton;
    SDL_Rect settingsButton;
    SDL_Rect exitButton;
    SDL_Texture* titleTexture;
    bool isMouseOnButton(int mx, int my, const SDL_Rect& button);
};

#endif


mainMenu.cpp
#include "mainMenu.h"
#include <iostream>

MainMenu::MainMenu() : playerButton({300, 300, 200, 60}), gameButton({300, 380, 200, 60}),
    settingsButton({300, 460, 200, 60}), exitButton({300, 540, 200, 60}), titleTexture(nullptr) {}

MainMenu::~MainMenu() {
    if (titleTexture) SDL_DestroyTexture(titleTexture);
}

void MainMenu::init(SDL_Renderer* renderer, TTF_Font* font) {
    titleTexture = createTextTexture(renderer, font, "Главное меню", textColor, 400);
    if (!titleTexture) {
        std::cerr << "Ошибка создания текстуры заголовка" << std::endl;
    }
}

void MainMenu::handleEvents(SDL_Event& event, int& scene, bool& running, int mx, int my) {
    bool mouseOnPlayer = isMouseOnButton(mx, my, playerButton);
    bool mouseOnGame = isMouseOnButton(mx, my, gameButton);
    bool mouseOnSettings = isMouseOnButton(mx, my, settingsButton);
    bool mouseOnExit = isMouseOnButton(mx, my, exitButton);

    if (event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT) {
        if (mouseOnPlayer) {
            scene = 0; // Плеер
        } else if (mouseOnGame) {
            scene = 1; // Tower Defense
        } else if (mouseOnSettings) {
            scene = 2; // Настройки
        } else if (mouseOnExit) {
            running = false; // Выход
        }
    }
}

void MainMenu::render(SDL_Renderer* renderer, TTF_Font* font, int mx, int my) {
    bool mouseOnPlayer = isMouseOnButton(mx, my, playerButton);
    bool mouseOnGame = isMouseOnButton(mx, my, gameButton);
    bool mouseOnSettings = isMouseOnButton(mx, my, settingsButton);
    bool mouseOnExit = isMouseOnButton(mx, my, exitButton);

    // Рендеринг кнопок
    SDL_SetRenderDrawColor(renderer, mouseOnPlayer ? buttonHoverColor.r : buttonColor.r,
        mouseOnPlayer ? buttonHoverColor.g : buttonColor.g,
        mouseOnPlayer ? buttonHoverColor.b : buttonColor.b, 255);
    SDL_Rect scaledPlayerButton = {playerButton.x - (mouseOnPlayer ? 5 : 0), playerButton.y - (mouseOnPlayer ? 5 : 0),
        playerButton.w + (mouseOnPlayer ? 10 : 0), playerButton.h + (mouseOnPlayer ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledPlayerButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledPlayerButton);

    SDL_SetRenderDrawColor(renderer, mouseOnGame ? buttonHoverColor.r : buttonColor.r,
        mouseOnGame ? buttonHoverColor.g : buttonColor.g,
        mouseOnGame ? buttonHoverColor.b : buttonColor.b, 255);
    SDL_Rect scaledGameButton = {gameButton.x - (mouseOnGame ? 5 : 0), gameButton.y - (mouseOnGame ? 5 : 0),
        gameButton.w + (mouseOnGame ? 10 : 0), gameButton.h + (mouseOnGame ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledGameButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledGameButton);

    SDL_SetRenderDrawColor(renderer, mouseOnSettings ? buttonHoverColor.r : buttonColor.r,
        mouseOnSettings ? buttonHoverColor.g : buttonColor.g,
        mouseOnSettings ? buttonHoverColor.b : buttonColor.b, 255);
    SDL_Rect scaledSettingsButton = {settingsButton.x - (mouseOnSettings ? 5 : 0), settingsButton.y - (mouseOnSettings ? 5 : 0),
        settingsButton.w + (mouseOnSettings ? 10 : 0), settingsButton.h + (mouseOnSettings ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledSettingsButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledSettingsButton);

    SDL_SetRenderDrawColor(renderer, mouseOnExit ? buttonHoverColor.r : buttonColor.r,
        mouseOnExit ? buttonHoverColor.g : buttonColor.g,
        mouseOnExit ? buttonHoverColor.b : buttonColor.b, 255);
    SDL_Rect scaledExitButton = {exitButton.x - (mouseOnExit ? 5 : 0), exitButton.y - (mouseOnExit ? 5 : 0),
        exitButton.w + (mouseOnExit ? 10 : 0), exitButton.h + (mouseOnExit ? 10 : 0)};
    SDL_RenderFillRect(renderer, &scaledExitButton);
    SDL_SetRenderDrawColor(renderer, borderColor.r, borderColor.g, borderColor.b, borderColor.a);
    SDL_RenderDrawRect(renderer, &scaledExitButton);

    // Рендеринг текста кнопок
    SDL_Texture* playerText = createTextTexture(renderer, font, "Музыкальный плеер", textColor, 180);
    if (playerText) {
        int tw, th;
        SDL_QueryTexture(playerText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledPlayerButton.x + (scaledPlayerButton.w - tw) / 2, scaledPlayerButton.y + (scaledPlayerButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(playerText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(playerText, shadowColor.a);
        SDL_RenderCopy(renderer, playerText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(playerText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(playerText, 255);
        SDL_RenderCopy(renderer, playerText, nullptr, &tr);
        SDL_DestroyTexture(playerText);
    }

    SDL_Texture* gameText = createTextTexture(renderer, font, "Tower Defense", textColor, 180);
    if (gameText) {
        int tw, th;
        SDL_QueryTexture(gameText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledGameButton.x + (scaledGameButton.w - tw) / 2, scaledGameButton.y + (scaledGameButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(gameText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(gameText, shadowColor.a);
        SDL_RenderCopy(renderer, gameText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(gameText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(gameText, 255);
        SDL_RenderCopy(renderer, gameText, nullptr, &tr);
        SDL_DestroyTexture(gameText);
    }

    SDL_Texture* settingsText = createTextTexture(renderer, font, "Настройки", textColor, 180);
    if (settingsText) {
        int tw, th;
        SDL_QueryTexture(settingsText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledSettingsButton.x + (scaledSettingsButton.w - tw) / 2, scaledSettingsButton.y + (scaledSettingsButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(settingsText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(settingsText, shadowColor.a);
        SDL_RenderCopy(renderer, settingsText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(settingsText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(settingsText, 255);
        SDL_RenderCopy(renderer, settingsText, nullptr, &tr);
        SDL_DestroyTexture(settingsText);
    }

    SDL_Texture* exitText = createTextTexture(renderer, font, "Выход", textColor, 180);
    if (exitText) {
        int tw, th;
        SDL_QueryTexture(exitText, nullptr, nullptr, &tw, &th);
        SDL_Rect tr = {scaledExitButton.x + (scaledExitButton.w - tw) / 2, scaledExitButton.y + (scaledExitButton.h - th) / 2, tw, th};
        SDL_Rect shadowTr = {tr.x + 2, tr.y + 2, tw, th};
        SDL_SetTextureColorMod(exitText, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(exitText, shadowColor.a);
        SDL_RenderCopy(renderer, exitText, nullptr, &shadowTr);
        SDL_SetTextureColorMod(exitText, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(exitText, 255);
        SDL_RenderCopy(renderer, exitText, nullptr, &tr);
        SDL_DestroyTexture(exitText);
    }

    // Рендеринг заголовка
    if (titleTexture) {
        int tw, th;
        SDL_QueryTexture(titleTexture, nullptr, nullptr, &tw, &th);
        SDL_Rect titleRect = {400 - tw / 2, 100, tw, th};
        SDL_Rect shadowRect = {titleRect.x + 3, titleRect.y + 3, tw, th};
        SDL_SetTextureColorMod(titleTexture, shadowColor.r, shadowColor.g, shadowColor.b);
        SDL_SetTextureAlphaMod(titleTexture, shadowColor.a);
        SDL_RenderCopy(renderer, titleTexture, nullptr, &shadowRect);
        SDL_SetTextureColorMod(titleTexture, textColor.r, textColor.g, textColor.b);
        SDL_SetTextureAlphaMod(titleTexture, 255);
        SDL_RenderCopy(renderer, titleTexture, nullptr, &titleRect);
    }
}

bool MainMenu::isMouseOnButton(int mx, int my, const SDL_Rect& button) {
    SDL_Rect cursor = {mx, my, 2, 2};
    return SDL_HasIntersection(&cursor, &button);
}


common.h
#ifndef COMMON_H
#define COMMON_H
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_mixer.h>
#include <string>

const SDL_Color textColor = {200, 200, 200, 255}; // Светло-серый текст
const SDL_Color shadowColor = {50, 50, 50, 100}; // Тёмная тень
const SDL_Color buttonColor = {40, 40, 60, 255}; // Тёмно-синий для кнопок
const SDL_Color buttonHoverColor = {60, 60, 90, 255}; // Светлее при наведении
const SDL_Color borderColor = {100, 100, 100, 255}; // Серый для границ
const SDL_Color backgroundColor = {30, 30, 30, 255}; // Тёмно-серый фон

SDL_Texture* createTextTexture(SDL_Renderer* renderer, TTF_Font* font, const std::string& text, SDL_Color color, int maxWidth = 0);
std::string formatTime(double seconds);
#endif

common.cpp
#include "common.h"
#include <iostream>

SDL_Texture* createTextTexture(SDL_Renderer* renderer, TTF_Font* font, const std::string& text, SDL_Color color, int maxWidth) {
    if (text.empty() || !font || !renderer) return nullptr;
    SDL_Surface* surface = TTF_RenderUTF8_Blended_Wrapped(font, text.c_str(), color, maxWidth);
    if (!surface) {
        std::cerr << "Ошибка создания поверхности текста: " << TTF_GetError() << std::endl;
        return nullptr;
    }
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    if (!texture) {
        std::cerr << "Ошибка создания текстуры текста: " << SDL_GetError() << std::endl;
    }
    SDL_FreeSurface(surface);
    return texture;
}

std::string formatTime(double seconds) {
    int minutes = static_cast<int>(seconds) / 60;
    int secs = static_cast<int>(seconds) % 60;
    char buffer[16];
    snprintf(buffer, sizeof(buffer), "%02d:%02d", minutes, secs);
    return std::string(buffer);
}



